; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\uart.o --asm_dir=.\Flash\ --list_dir=.\Flash\ --depend=.\flash\uart.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\Lib\Drivers\include -I.\Inc -I.\Lib\Usb_Drivers\Inc -I.\Lib\CLib__1_0_0_4\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\NXP\LPC17xx -D__UVISION_VERSION=525 --omf_browse=.\flash\uart.crf Lib\Usb_Drivers\Src\uart.c]
                          THUMB

                          AREA ||i.NVIC_DisableIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_DisableIRQ PROC
;;;1345    */
;;;1346   __STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1347   {
;;;1348     NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a02              LDR      r2,|L1.20|
00000a  0943              LSRS     r3,r0,#5
00000c  f8421023          STR      r1,[r2,r3,LSL #2]
;;;1349   }
000010  4770              BX       lr
;;;1350   
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      0xe000e180

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1333    */
;;;1334   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1335   {
;;;1336     NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0942              LSRS     r2,r0,#5
00000a  0092              LSLS     r2,r2,#2
00000c  f10222e0          ADD      r2,r2,#0xe000e000
000010  f8c21100          STR      r1,[r2,#0x100]
;;;1337   }
000014  4770              BX       lr
;;;1338   
                          ENDP


                          AREA ||i.UART0_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART0_IRQHandler PROC
;;;352     *---------------------------------------------------------------------------*/
;;;353    void UART0_IRQHandler(void)
000000  b508              PUSH     {r3,lr}
;;;354    {
;;;355      volatile unsigned long iir;
;;;356    
;;;357      iir = LPC_UART0->IIR;
000002  4826              LDR      r0,|L3.156|
000004  6880              LDR      r0,[r0,#8]
000006  9000              STR      r0,[sp,#0]
;;;358    
;;;359      if ((iir & 0x4) || (iir & 0xC)) {            // RDA or CTI pending
000008  9800              LDR      r0,[sp,#0]
00000a  f0000004          AND      r0,r0,#4
00000e  b918              CBNZ     r0,|L3.24|
000010  9800              LDR      r0,[sp,#0]
000012  f000000c          AND      r0,r0,#0xc
000016  b1a8              CBZ      r0,|L3.68|
                  |L3.24|
;;;360        while (LPC_UART0->LSR & 0x01) {                 // Rx FIFO is not empty
000018  e00e              B        |L3.56|
                  |L3.26|
;;;361          SER_BUF_WR(ser_in, LPC_UART0->RBR);           // Read Rx FIFO to buffer
00001a  4820              LDR      r0,|L3.156|
00001c  7801              LDRB     r1,[r0,#0]
00001e  4820              LDR      r0,|L3.160|
000020  f8902080          LDRB     r2,[r0,#0x80]  ; ser_in
000024  f8d00080          LDR      r0,[r0,#0x80]  ; ser_in
000028  1c40              ADDS     r0,r0,#1
00002a  4b1d              LDR      r3,|L3.160|
00002c  f8c30080          STR      r0,[r3,#0x80]  ; ser_in
000030  f002007f          AND      r0,r2,#0x7f
000034  461a              MOV      r2,r3
000036  5411              STRB     r1,[r2,r0]
                  |L3.56|
000038  4818              LDR      r0,|L3.156|
00003a  7d00              LDRB     r0,[r0,#0x14]         ;360
00003c  f0000001          AND      r0,r0,#1              ;360
000040  2800              CMP      r0,#0                 ;360
000042  d1ea              BNE      |L3.26|
                  |L3.68|
;;;362        }
;;;363      }
;;;364      if ((iir & 0x2)) {                           // TXMIS pending
000044  9800              LDR      r0,[sp,#0]
000046  f0000002          AND      r0,r0,#2
00004a  b1f8              CBZ      r0,|L3.140|
;;;365    	if (SER_BUF_COUNT(ser_out) != 0) {
00004c  4815              LDR      r0,|L3.164|
00004e  f8900080          LDRB     r0,[r0,#0x80]  ; ser_out
000052  4914              LDR      r1,|L3.164|
000054  f8911084          LDRB     r1,[r1,#0x84]  ; ser_out
000058  1a40              SUBS     r0,r0,r1
00005a  f000007f          AND      r0,r0,#0x7f
00005e  b190              CBZ      r0,|L3.134|
;;;366          LPC_UART0->THR = SER_BUF_RD(ser_out);         // Write to the Tx FIFO
000060  4810              LDR      r0,|L3.164|
000062  f8901084          LDRB     r1,[r0,#0x84]  ; ser_out
000066  f8d00084          LDR      r0,[r0,#0x84]  ; ser_out
00006a  1c40              ADDS     r0,r0,#1
00006c  4a0d              LDR      r2,|L3.164|
00006e  f8c20084          STR      r0,[r2,#0x84]  ; ser_out
000072  f001007f          AND      r0,r1,#0x7f
000076  4611              MOV      r1,r2
000078  5c08              LDRB     r0,[r1,r0]
00007a  4908              LDR      r1,|L3.156|
00007c  7008              STRB     r0,[r1,#0]
;;;367          ser_txRestart = 0;
00007e  2000              MOVS     r0,#0
000080  4909              LDR      r1,|L3.168|
000082  6008              STR      r0,[r1,#0]  ; ser_txRestart
000084  e002              B        |L3.140|
                  |L3.134|
;;;368        }
;;;369    	else {
;;;370          ser_txRestart = 1;
000086  2001              MOVS     r0,#1
000088  4907              LDR      r1,|L3.168|
00008a  6008              STR      r0,[r1,#0]  ; ser_txRestart
                  |L3.140|
;;;371    	}
;;;372      }
;;;373      ser_lineState = LPC_UART0->LSR & 0x1E;            // update linestate
00008c  4803              LDR      r0,|L3.156|
00008e  7d00              LDRB     r0,[r0,#0x14]
000090  f000001e          AND      r0,r0,#0x1e
000094  4905              LDR      r1,|L3.172|
000096  8008              STRH     r0,[r1,#0]
;;;374      return;
;;;375    }
000098  bd08              POP      {r3,pc}
;;;376    
                          ENDP

00009a  0000              DCW      0x0000
                  |L3.156|
                          DCD      0x4000c000
                  |L3.160|
                          DCD      ser_in
                  |L3.164|
                          DCD      ser_out
                  |L3.168|
                          DCD      ser_txRestart
                  |L3.172|
                          DCD      ser_lineState

                          AREA ||i.UART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART1_IRQHandler PROC
;;;379     *---------------------------------------------------------------------------*/
;;;380    void UART1_IRQHandler(void)
000000  b508              PUSH     {r3,lr}
;;;381    {
;;;382      volatile unsigned long iir;
;;;383    
;;;384      iir = LPC_UART1->IIR;
000002  4828              LDR      r0,|L4.164|
000004  6880              LDR      r0,[r0,#8]
000006  9000              STR      r0,[sp,#0]
;;;385    
;;;386      if ((iir & 0x4) || (iir & 0xC)) {            // RDA or CTI pending
000008  9800              LDR      r0,[sp,#0]
00000a  f0000004          AND      r0,r0,#4
00000e  b918              CBNZ     r0,|L4.24|
000010  9800              LDR      r0,[sp,#0]
000012  f000000c          AND      r0,r0,#0xc
000016  b1a8              CBZ      r0,|L4.68|
                  |L4.24|
;;;387        while (LPC_UART1->LSR & 0x01) {                 // Rx FIFO is not empty
000018  e00e              B        |L4.56|
                  |L4.26|
;;;388          SER_BUF_WR(ser_in, LPC_UART1->RBR);           // Read Rx FIFO to buffer
00001a  4822              LDR      r0,|L4.164|
00001c  7801              LDRB     r1,[r0,#0]
00001e  4822              LDR      r0,|L4.168|
000020  f8902080          LDRB     r2,[r0,#0x80]  ; ser_in
000024  f8d00080          LDR      r0,[r0,#0x80]  ; ser_in
000028  1c40              ADDS     r0,r0,#1
00002a  4b1f              LDR      r3,|L4.168|
00002c  f8c30080          STR      r0,[r3,#0x80]  ; ser_in
000030  f002007f          AND      r0,r2,#0x7f
000034  461a              MOV      r2,r3
000036  5411              STRB     r1,[r2,r0]
                  |L4.56|
000038  481a              LDR      r0,|L4.164|
00003a  7d00              LDRB     r0,[r0,#0x14]         ;387
00003c  f0000001          AND      r0,r0,#1              ;387
000040  2800              CMP      r0,#0                 ;387
000042  d1ea              BNE      |L4.26|
                  |L4.68|
;;;389        }
;;;390      }
;;;391      if ((iir & 0x2)) {                           // TXMIS pending
000044  9800              LDR      r0,[sp,#0]
000046  f0000002          AND      r0,r0,#2
00004a  b1f8              CBZ      r0,|L4.140|
;;;392    	if (SER_BUF_COUNT(ser_out) != 0) {
00004c  4817              LDR      r0,|L4.172|
00004e  f8900080          LDRB     r0,[r0,#0x80]  ; ser_out
000052  4916              LDR      r1,|L4.172|
000054  f8911084          LDRB     r1,[r1,#0x84]  ; ser_out
000058  1a40              SUBS     r0,r0,r1
00005a  f000007f          AND      r0,r0,#0x7f
00005e  b190              CBZ      r0,|L4.134|
;;;393          LPC_UART1->THR = SER_BUF_RD(ser_out);         // Write to the Tx FIFO
000060  4812              LDR      r0,|L4.172|
000062  f8901084          LDRB     r1,[r0,#0x84]  ; ser_out
000066  f8d00084          LDR      r0,[r0,#0x84]  ; ser_out
00006a  1c40              ADDS     r0,r0,#1
00006c  4a0f              LDR      r2,|L4.172|
00006e  f8c20084          STR      r0,[r2,#0x84]  ; ser_out
000072  f001007f          AND      r0,r1,#0x7f
000076  4611              MOV      r1,r2
000078  5c08              LDRB     r0,[r1,r0]
00007a  490a              LDR      r1,|L4.164|
00007c  7008              STRB     r0,[r1,#0]
;;;394          ser_txRestart = 0;
00007e  2000              MOVS     r0,#0
000080  490b              LDR      r1,|L4.176|
000082  6008              STR      r0,[r1,#0]  ; ser_txRestart
000084  e002              B        |L4.140|
                  |L4.134|
;;;395        }
;;;396    	else {
;;;397          ser_txRestart = 1;
000086  2001              MOVS     r0,#1
000088  4909              LDR      r1,|L4.176|
00008a  6008              STR      r0,[r1,#0]  ; ser_txRestart
                  |L4.140|
;;;398    	}
;;;399      }
;;;400      ser_lineState = ((LPC_UART1->MSR<<8)|LPC_UART1->LSR) & 0xE01E;    // update linestate
00008c  4805              LDR      r0,|L4.164|
00008e  7d00              LDRB     r0,[r0,#0x14]
000090  4904              LDR      r1,|L4.164|
000092  7e09              LDRB     r1,[r1,#0x18]
000094  ea402001          ORR      r0,r0,r1,LSL #8
000098  f24e011e          MOV      r1,#0xe01e
00009c  4008              ANDS     r0,r0,r1
00009e  4905              LDR      r1,|L4.180|
0000a0  8008              STRH     r0,[r1,#0]
;;;401      return;
;;;402    }
0000a2  bd08              POP      {r3,pc}
;;;403    
                          ENDP

                  |L4.164|
                          DCD      0x40010000
                  |L4.168|
                          DCD      ser_in
                  |L4.172|
                          DCD      ser_out
                  |L4.176|
                          DCD      ser_txRestart
                  |L4.180|
                          DCD      ser_lineState

                          AREA ||i.ser_AvailChar||, CODE, READONLY, ALIGN=2

                  ser_AvailChar PROC
;;;333     *---------------------------------------------------------------------------*/
;;;334    void ser_AvailChar (int *availChar) {
000000  4905              LDR      r1,|L5.24|
;;;335    
;;;336      *availChar = SER_BUF_COUNT(ser_in);
000002  f8911080          LDRB     r1,[r1,#0x80]  ; ser_in
000006  4a04              LDR      r2,|L5.24|
000008  f8922084          LDRB     r2,[r2,#0x84]  ; ser_in
00000c  1a89              SUBS     r1,r1,r2
00000e  f001017f          AND      r1,r1,#0x7f
000012  6001              STR      r1,[r0,#0]
;;;337    
;;;338    }
000014  4770              BX       lr
;;;339    
                          ENDP

000016  0000              DCW      0x0000
                  |L5.24|
                          DCD      ser_in

                          AREA ||i.ser_ClosePort||, CODE, READONLY, ALIGN=2

                  ser_ClosePort PROC
;;;71      *---------------------------------------------------------------------------*/
;;;72     void ser_ClosePort (char portNum ) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;73       if ( portNum == 0 )
000004  b964              CBNZ     r4,|L6.32|
;;;74       {
;;;75     	/* POrt 0 */
;;;76     	LPC_PINCON->PINSEL0 &= ~0x000000F0;
000006  480d              LDR      r0,|L6.60|
000008  6800              LDR      r0,[r0,#0]
00000a  f02000f0          BIC      r0,r0,#0xf0
00000e  490b              LDR      r1,|L6.60|
000010  6008              STR      r0,[r1,#0]
;;;77     	/* Disable the interrupt in the VIC and UART controllers */
;;;78     	LPC_UART0->IER = 0;
000012  2000              MOVS     r0,#0
000014  490a              LDR      r1,|L6.64|
000016  6048              STR      r0,[r1,#4]
;;;79     	NVIC_DisableIRQ(UART0_IRQn);
000018  2005              MOVS     r0,#5
00001a  f7fffffe          BL       NVIC_DisableIRQ
00001e  e00b              B        |L6.56|
                  |L6.32|
;;;80       }
;;;81       else
;;;82       {
;;;83     	/* Port 1 */
;;;84     	LPC_PINCON->PINSEL4 &= ~0x0000000F;
000020  4806              LDR      r0,|L6.60|
000022  6900              LDR      r0,[r0,#0x10]
000024  f020000f          BIC      r0,r0,#0xf
000028  4904              LDR      r1,|L6.60|
00002a  6108              STR      r0,[r1,#0x10]
;;;85     	/* Disable the interrupt in the VIC and UART controllers */
;;;86     	LPC_UART1->IER = 0;
00002c  2000              MOVS     r0,#0
00002e  4905              LDR      r1,|L6.68|
000030  6048              STR      r0,[r1,#4]
;;;87     	NVIC_DisableIRQ(UART1_IRQn);
000032  2006              MOVS     r0,#6
000034  f7fffffe          BL       NVIC_DisableIRQ
                  |L6.56|
;;;88       }
;;;89       return;
;;;90     }
000038  bd10              POP      {r4,pc}
;;;91     
                          ENDP

00003a  0000              DCW      0x0000
                  |L6.60|
                          DCD      0x4002c000
                  |L6.64|
                          DCD      0x4000c000
                  |L6.68|
                          DCD      0x40010000

                          AREA ||i.ser_InitPort0||, CODE, READONLY, ALIGN=2

                  ser_InitPort0 PROC
;;;94      *---------------------------------------------------------------------------*/
;;;95     void ser_InitPort0 (unsigned long baudrate, unsigned int  databits,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;96                       unsigned int  parity,   unsigned int  stopbits) {
000004  4682              MOV      r10,r0
000006  4690              MOV      r8,r2
;;;97     
;;;98       unsigned char lcr_p, lcr_s, lcr_d;
;;;99       unsigned int dll;
;;;100      unsigned int pclkdiv, pclk;
;;;101    
;;;102      switch (databits) {
000008  9801              LDR      r0,[sp,#4]
00000a  2805              CMP      r0,#5
00000c  d006              BEQ      |L7.28|
00000e  2806              CMP      r0,#6
000010  d006              BEQ      |L7.32|
000012  2807              CMP      r0,#7
000014  d006              BEQ      |L7.36|
000016  2808              CMP      r0,#8
000018  d106              BNE      |L7.40|
00001a  e006              B        |L7.42|
                  |L7.28|
;;;103        case 5:                                            // 5 Data bits
;;;104          lcr_d = 0x00;
00001c  2500              MOVS     r5,#0
;;;105        break;
00001e  e006              B        |L7.46|
                  |L7.32|
;;;106        case 6:                                            // 6 Data bits
;;;107          lcr_d = 0x01;
000020  2501              MOVS     r5,#1
;;;108        break;
000022  e004              B        |L7.46|
                  |L7.36|
;;;109        case 7:                                            // 7 Data bits
;;;110          lcr_d = 0x02;
000024  2502              MOVS     r5,#2
;;;111        break;
000026  e002              B        |L7.46|
                  |L7.40|
;;;112        case 8:                                            // 8 Data bits
000028  bf00              NOP      
                  |L7.42|
;;;113        default:
;;;114          lcr_d = 0x03;
00002a  2503              MOVS     r5,#3
;;;115        break;
00002c  bf00              NOP      
                  |L7.46|
00002e  bf00              NOP                            ;105
;;;116      }
;;;117    
;;;118      switch (stopbits) {
000030  9803              LDR      r0,[sp,#0xc]
000032  b140              CBZ      r0,|L7.70|
000034  2801              CMP      r0,#1
000036  d002              BEQ      |L7.62|
000038  2802              CMP      r0,#2
00003a  d103              BNE      |L7.68|
00003c  e000              B        |L7.64|
                  |L7.62|
;;;119        case 1:                                            // 1,5 Stop bits
;;;120        case 2:                                            // 2   Stop bits
00003e  bf00              NOP      
                  |L7.64|
;;;121          lcr_s = 0x04;
000040  2704              MOVS     r7,#4
;;;122        break;
000042  e002              B        |L7.74|
                  |L7.68|
;;;123        case 0:                                            // 1   Stop bit
000044  bf00              NOP      
                  |L7.70|
;;;124        default:
;;;125          lcr_s = 0x00;
000046  2700              MOVS     r7,#0
;;;126        break;
000048  bf00              NOP      
                  |L7.74|
00004a  bf00              NOP                            ;122
;;;127      }
;;;128    
;;;129      switch (parity) {
00004c  f1b80f05          CMP      r8,#5
000050  d20c              BCS      |L7.108|
000052  e8dff008          TBB      [pc,r8]
000056  0c03              DCB      0x0c,0x03
000058  05070900          DCB      0x05,0x07,0x09,0x00
;;;130        case 1:                                            // Parity Odd
;;;131          lcr_p = 0x08;
00005c  2408              MOVS     r4,#8
;;;132        break;
00005e  e008              B        |L7.114|
;;;133        case 2:                                            // Parity Even
;;;134          lcr_p = 0x18;
000060  2418              MOVS     r4,#0x18
;;;135        break;
000062  e006              B        |L7.114|
;;;136        case 3:                                            // Parity Mark
;;;137          lcr_p = 0x28;
000064  2428              MOVS     r4,#0x28
;;;138        break;
000066  e004              B        |L7.114|
;;;139        case 4:                                            // Parity Space
;;;140          lcr_p = 0x38;
000068  2438              MOVS     r4,#0x38
;;;141        break;
00006a  e002              B        |L7.114|
                  |L7.108|
;;;142        case 0:                                            // Parity None
00006c  bf00              NOP      
;;;143        default:
;;;144          lcr_p = 0x00;
00006e  2400              MOVS     r4,#0
;;;145        break;
000070  bf00              NOP      
                  |L7.114|
000072  bf00              NOP                            ;132
;;;146      }
;;;147    
;;;148      SER_BUF_RESET(ser_out);                              // reset out buffer
000074  2000              MOVS     r0,#0
000076  4926              LDR      r1,|L7.272|
000078  f8c10080          STR      r0,[r1,#0x80]  ; ser_out
00007c  f8c10084          STR      r0,[r1,#0x84]  ; ser_out
;;;149      SER_BUF_RESET(ser_in);                               // reset in buffer
000080  4924              LDR      r1,|L7.276|
000082  f8c10080          STR      r0,[r1,#0x80]  ; ser_in
000086  f8c10084          STR      r0,[r1,#0x84]  ; ser_in
;;;150    
;;;151      /* Bit 6~7 is for UART0 */
;;;152      pclkdiv = (LPC_SC->PCLKSEL0 >> 6) & 0x03;
00008a  4823              LDR      r0,|L7.280|
00008c  6800              LDR      r0,[r0,#0]
00008e  f3c01b81          UBFX     r11,r0,#6,#2
;;;153    
;;;154      switch ( pclkdiv )
000092  f1bb0f00          CMP      r11,#0
000096  d009              BEQ      |L7.172|
000098  f1bb0f01          CMP      r11,#1
00009c  d00a              BEQ      |L7.180|
00009e  f1bb0f02          CMP      r11,#2
0000a2  d00a              BEQ      |L7.186|
0000a4  f1bb0f03          CMP      r11,#3
0000a8  d00b              BEQ      |L7.194|
;;;155      {
;;;156    	case 0x00:
0000aa  bf00              NOP      
                  |L7.172|
;;;157    	default:
;;;158    	  pclk = SystemCoreClock/4;
0000ac  481b              LDR      r0,|L7.284|
0000ae  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
0000b0  0886              LSRS     r6,r0,#2
;;;159    	  break;
0000b2  e00a              B        |L7.202|
                  |L7.180|
;;;160    	case 0x01:
;;;161    	  pclk = SystemCoreClock;
0000b4  4819              LDR      r0,|L7.284|
0000b6  6806              LDR      r6,[r0,#0]  ; SystemCoreClock
;;;162    	  break;
0000b8  e007              B        |L7.202|
                  |L7.186|
;;;163    	case 0x02:
;;;164    	  pclk = SystemCoreClock/2;
0000ba  4818              LDR      r0,|L7.284|
0000bc  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
0000be  0846              LSRS     r6,r0,#1
;;;165    	  break;
0000c0  e003              B        |L7.202|
                  |L7.194|
;;;166    	case 0x03:
;;;167    	  pclk = SystemCoreClock/8;
0000c2  4816              LDR      r0,|L7.284|
0000c4  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
0000c6  08c6              LSRS     r6,r0,#3
;;;168    	  break;
0000c8  bf00              NOP      
                  |L7.202|
0000ca  bf00              NOP                            ;159
;;;169      }
;;;170    
;;;171      dll = (pclk/16)/baudrate ;	/*baud rate */
0000cc  0930              LSRS     r0,r6,#4
0000ce  fbb0f9fa          UDIV     r9,r0,r10
;;;172      LPC_UART0->FDR = 0;                             // Fractional divider not used
0000d2  2000              MOVS     r0,#0
0000d4  4912              LDR      r1,|L7.288|
0000d6  7008              STRB     r0,[r1,#0]
;;;173      LPC_UART0->LCR = 0x80 | lcr_d | lcr_p | lcr_s;  // Data bits, Parity,   Stop bit
0000d8  f0450080          ORR      r0,r5,#0x80
0000dc  4320              ORRS     r0,r0,r4
0000de  4338              ORRS     r0,r0,r7
0000e0  490f              LDR      r1,|L7.288|
0000e2  3928              SUBS     r1,r1,#0x28
0000e4  7308              STRB     r0,[r1,#0xc]
;;;174      LPC_UART0->DLL = dll;                           // Baud Rate depending on PCLK
0000e6  f8819000          STRB     r9,[r1,#0]
;;;175      LPC_UART0->DLM = (dll >> 8);                    // High divisor latch
0000ea  ea4f2019          LSR      r0,r9,#8
0000ee  7108              STRB     r0,[r1,#4]
;;;176      LPC_UART0->LCR = 0x00 | lcr_d | lcr_p | lcr_s;  // DLAB = 0
0000f0  ea450004          ORR      r0,r5,r4
0000f4  4338              ORRS     r0,r0,r7
0000f6  7308              STRB     r0,[r1,#0xc]
;;;177      LPC_UART0->IER = 0x03;                          // Enable TX/RX interrupts
0000f8  2003              MOVS     r0,#3
0000fa  6048              STR      r0,[r1,#4]
;;;178    
;;;179      LPC_UART0->FCR = 0x07;				/* Enable and reset TX and RX FIFO. */
0000fc  2007              MOVS     r0,#7
0000fe  7208              STRB     r0,[r1,#8]
;;;180      ser_txRestart = 1;                                   // TX fifo is empty
000100  2001              MOVS     r0,#1
000102  4908              LDR      r1,|L7.292|
000104  6008              STR      r0,[r1,#0]  ; ser_txRestart
;;;181    
;;;182      /* Enable the UART Interrupt */
;;;183      NVIC_EnableIRQ(UART0_IRQn);
000106  2005              MOVS     r0,#5
000108  f7fffffe          BL       NVIC_EnableIRQ
;;;184      return;
;;;185    }
00010c  e8bd9fff          POP      {r0-r12,pc}
;;;186    
                          ENDP

                  |L7.272|
                          DCD      ser_out
                  |L7.276|
                          DCD      ser_in
                  |L7.280|
                          DCD      0x400fc1a8
                  |L7.284|
                          DCD      SystemCoreClock
                  |L7.288|
                          DCD      0x4000c028
                  |L7.292|
                          DCD      ser_txRestart

                          AREA ||i.ser_InitPort1||, CODE, READONLY, ALIGN=2

                  ser_InitPort1 PROC
;;;189     *---------------------------------------------------------------------------*/
;;;190    void ser_InitPort1 (unsigned long baudrate, unsigned int  databits,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;191                      unsigned int  parity,   unsigned int  stopbits) {
000004  4682              MOV      r10,r0
000006  4690              MOV      r8,r2
;;;192    
;;;193      unsigned char lcr_p, lcr_s, lcr_d;
;;;194      unsigned int dll;
;;;195      unsigned int pclkdiv, pclk;
;;;196    
;;;197      switch (databits) {
000008  9801              LDR      r0,[sp,#4]
00000a  2805              CMP      r0,#5
00000c  d006              BEQ      |L8.28|
00000e  2806              CMP      r0,#6
000010  d006              BEQ      |L8.32|
000012  2807              CMP      r0,#7
000014  d006              BEQ      |L8.36|
000016  2808              CMP      r0,#8
000018  d106              BNE      |L8.40|
00001a  e006              B        |L8.42|
                  |L8.28|
;;;198        case 5:                                            // 5 Data bits
;;;199          lcr_d = 0x00;
00001c  2500              MOVS     r5,#0
;;;200        break;
00001e  e006              B        |L8.46|
                  |L8.32|
;;;201        case 6:                                            // 6 Data bits
;;;202          lcr_d = 0x01;
000020  2501              MOVS     r5,#1
;;;203        break;
000022  e004              B        |L8.46|
                  |L8.36|
;;;204        case 7:                                            // 7 Data bits
;;;205          lcr_d = 0x02;
000024  2502              MOVS     r5,#2
;;;206        break;
000026  e002              B        |L8.46|
                  |L8.40|
;;;207        case 8:                                            // 8 Data bits
000028  bf00              NOP      
                  |L8.42|
;;;208        default:
;;;209          lcr_d = 0x03;
00002a  2503              MOVS     r5,#3
;;;210        break;
00002c  bf00              NOP      
                  |L8.46|
00002e  bf00              NOP                            ;200
;;;211      }
;;;212    
;;;213      switch (stopbits) {
000030  9803              LDR      r0,[sp,#0xc]
000032  b140              CBZ      r0,|L8.70|
000034  2801              CMP      r0,#1
000036  d002              BEQ      |L8.62|
000038  2802              CMP      r0,#2
00003a  d103              BNE      |L8.68|
00003c  e000              B        |L8.64|
                  |L8.62|
;;;214        case 1:                                            // 1,5 Stop bits
;;;215        case 2:                                            // 2   Stop bits
00003e  bf00              NOP      
                  |L8.64|
;;;216          lcr_s = 0x04;
000040  2704              MOVS     r7,#4
;;;217        break;
000042  e002              B        |L8.74|
                  |L8.68|
;;;218        case 0:                                            // 1   Stop bit
000044  bf00              NOP      
                  |L8.70|
;;;219        default:
;;;220          lcr_s = 0x00;
000046  2700              MOVS     r7,#0
;;;221        break;
000048  bf00              NOP      
                  |L8.74|
00004a  bf00              NOP                            ;217
;;;222      }
;;;223    
;;;224      switch (parity) {
00004c  f1b80f05          CMP      r8,#5
000050  d20c              BCS      |L8.108|
000052  e8dff008          TBB      [pc,r8]
000056  0c03              DCB      0x0c,0x03
000058  05070900          DCB      0x05,0x07,0x09,0x00
;;;225        case 1:                                            // Parity Odd
;;;226          lcr_p = 0x08;
00005c  2408              MOVS     r4,#8
;;;227        break;
00005e  e008              B        |L8.114|
;;;228        case 2:                                            // Parity Even
;;;229          lcr_p = 0x18;
000060  2418              MOVS     r4,#0x18
;;;230        break;
000062  e006              B        |L8.114|
;;;231        case 3:                                            // Parity Mark
;;;232          lcr_p = 0x28;
000064  2428              MOVS     r4,#0x28
;;;233        break;
000066  e004              B        |L8.114|
;;;234        case 4:                                            // Parity Space
;;;235          lcr_p = 0x38;
000068  2438              MOVS     r4,#0x38
;;;236        break;
00006a  e002              B        |L8.114|
                  |L8.108|
;;;237        case 0:                                            // Parity None
00006c  bf00              NOP      
;;;238        default:
;;;239          lcr_p = 0x00;
00006e  2400              MOVS     r4,#0
;;;240        break;
000070  bf00              NOP      
                  |L8.114|
000072  bf00              NOP                            ;227
;;;241      }
;;;242    
;;;243      SER_BUF_RESET(ser_out);                              // reset out buffer
000074  2000              MOVS     r0,#0
000076  4925              LDR      r1,|L8.268|
000078  f8c10080          STR      r0,[r1,#0x80]  ; ser_out
00007c  f8c10084          STR      r0,[r1,#0x84]  ; ser_out
;;;244      SER_BUF_RESET(ser_in);                               // reset in buffer
000080  4923              LDR      r1,|L8.272|
000082  f8c10080          STR      r0,[r1,#0x80]  ; ser_in
000086  f8c10084          STR      r0,[r1,#0x84]  ; ser_in
;;;245    
;;;246      /* Bit 8,9 are for UART1 */
;;;247      pclkdiv = (LPC_SC->PCLKSEL0 >> 8) & 0x03;
00008a  4822              LDR      r0,|L8.276|
00008c  6800              LDR      r0,[r0,#0]
00008e  f3c02b01          UBFX     r11,r0,#8,#2
;;;248    
;;;249      switch ( pclkdiv )
000092  f1bb0f00          CMP      r11,#0
000096  d009              BEQ      |L8.172|
000098  f1bb0f01          CMP      r11,#1
00009c  d00a              BEQ      |L8.180|
00009e  f1bb0f02          CMP      r11,#2
0000a2  d00a              BEQ      |L8.186|
0000a4  f1bb0f03          CMP      r11,#3
0000a8  d00b              BEQ      |L8.194|
;;;250      {
;;;251    	case 0x00:
0000aa  bf00              NOP      
                  |L8.172|
;;;252    	default:
;;;253    	  pclk = SystemCoreClock/4;
0000ac  481a              LDR      r0,|L8.280|
0000ae  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
0000b0  0886              LSRS     r6,r0,#2
;;;254    	  break;
0000b2  e00a              B        |L8.202|
                  |L8.180|
;;;255    	case 0x01:
;;;256    	  pclk = SystemCoreClock;
0000b4  4818              LDR      r0,|L8.280|
0000b6  6806              LDR      r6,[r0,#0]  ; SystemCoreClock
;;;257    	  break;
0000b8  e007              B        |L8.202|
                  |L8.186|
;;;258    	case 0x02:
;;;259    	  pclk = SystemCoreClock/2;
0000ba  4817              LDR      r0,|L8.280|
0000bc  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
0000be  0846              LSRS     r6,r0,#1
;;;260    	  break;
0000c0  e003              B        |L8.202|
                  |L8.194|
;;;261    	case 0x03:
;;;262    	  pclk = SystemCoreClock/8;
0000c2  4815              LDR      r0,|L8.280|
0000c4  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
0000c6  08c6              LSRS     r6,r0,#3
;;;263    	  break;
0000c8  bf00              NOP      
                  |L8.202|
0000ca  bf00              NOP                            ;254
;;;264      }
;;;265    
;;;266      dll = (pclk/16)/baudrate ;	/*baud rate */
0000cc  0930              LSRS     r0,r6,#4
0000ce  fbb0f9fa          UDIV     r9,r0,r10
;;;267      LPC_UART1->FDR = 0;                             // Fractional divider not used
0000d2  2000              MOVS     r0,#0
0000d4  4911              LDR      r1,|L8.284|
0000d6  6288              STR      r0,[r1,#0x28]
;;;268      LPC_UART1->LCR = 0x80 | lcr_d | lcr_p | lcr_s;  // Data bits, Parity,   Stop bit
0000d8  f0450080          ORR      r0,r5,#0x80
0000dc  4320              ORRS     r0,r0,r4
0000de  4338              ORRS     r0,r0,r7
0000e0  7308              STRB     r0,[r1,#0xc]
;;;269      LPC_UART1->DLL = dll;                           // Baud Rate depending on PCLK
0000e2  f8819000          STRB     r9,[r1,#0]
;;;270      LPC_UART1->DLM = (dll >> 8);                    // High divisor latch
0000e6  ea4f2019          LSR      r0,r9,#8
0000ea  7108              STRB     r0,[r1,#4]
;;;271      LPC_UART1->LCR = 0x00 | lcr_d | lcr_p | lcr_s;  // DLAB = 0
0000ec  ea450004          ORR      r0,r5,r4
0000f0  4338              ORRS     r0,r0,r7
0000f2  7308              STRB     r0,[r1,#0xc]
;;;272      LPC_UART1->IER = 0x03;                          // Enable TX/RX interrupts
0000f4  2003              MOVS     r0,#3
0000f6  6048              STR      r0,[r1,#4]
;;;273    
;;;274      LPC_UART1->FCR = 0x07;				/* Enable and reset TX and RX FIFO. */
0000f8  2007              MOVS     r0,#7
0000fa  7208              STRB     r0,[r1,#8]
;;;275      ser_txRestart = 1;                                   // TX fifo is empty
0000fc  2001              MOVS     r0,#1
0000fe  4908              LDR      r1,|L8.288|
000100  6008              STR      r0,[r1,#0]  ; ser_txRestart
;;;276    
;;;277      /* Enable the UART Interrupt */
;;;278      NVIC_EnableIRQ(UART1_IRQn);
000102  2006              MOVS     r0,#6
000104  f7fffffe          BL       NVIC_EnableIRQ
;;;279      return;
;;;280    }
000108  e8bd9fff          POP      {r0-r12,pc}
;;;281    
                          ENDP

                  |L8.268|
                          DCD      ser_out
                  |L8.272|
                          DCD      ser_in
                  |L8.276|
                          DCD      0x400fc1a8
                  |L8.280|
                          DCD      SystemCoreClock
                  |L8.284|
                          DCD      0x40010000
                  |L8.288|
                          DCD      ser_txRestart

                          AREA ||i.ser_LineState||, CODE, READONLY, ALIGN=2

                  ser_LineState PROC
;;;342     *---------------------------------------------------------------------------*/
;;;343    void ser_LineState (unsigned short *lineState) {
000000  4903              LDR      r1,|L9.16|
;;;344    
;;;345      *lineState = ser_lineState;
000002  8809              LDRH     r1,[r1,#0]  ; ser_lineState
000004  8001              STRH     r1,[r0,#0]
;;;346      ser_lineState = 0;
000006  2100              MOVS     r1,#0
000008  4a01              LDR      r2,|L9.16|
00000a  8011              STRH     r1,[r2,#0]
;;;347    
;;;348    }
00000c  4770              BX       lr
;;;349    
                          ENDP

00000e  0000              DCW      0x0000
                  |L9.16|
                          DCD      ser_lineState

                          AREA ||i.ser_OpenPort||, CODE, READONLY, ALIGN=2

                  ser_OpenPort PROC
;;;49      *---------------------------------------------------------------------------*/
;;;50     void ser_OpenPort (char portNum) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;51     
;;;52       if ( portNum == 0 )
000004  b974              CBNZ     r4,|L10.36|
;;;53       {
;;;54     	/* Port 0 */
;;;55     	NVIC_DisableIRQ(UART0_IRQn);
000006  2005              MOVS     r0,#5
000008  f7fffffe          BL       NVIC_DisableIRQ
;;;56     	LPC_PINCON->PINSEL0 &= ~0x000000F0;
00000c  480d              LDR      r0,|L10.68|
00000e  6800              LDR      r0,[r0,#0]
000010  f02000f0          BIC      r0,r0,#0xf0
000014  490b              LDR      r1,|L10.68|
000016  6008              STR      r0,[r1,#0]
;;;57     	LPC_PINCON->PINSEL0 |= 0x00000050;     /* RxD0 is P0.3 and TxD0 is P0.2 */
000018  4608              MOV      r0,r1
00001a  6800              LDR      r0,[r0,#0]
00001c  f0400050          ORR      r0,r0,#0x50
000020  6008              STR      r0,[r1,#0]
000022  e00d              B        |L10.64|
                  |L10.36|
;;;58       }
;;;59       else
;;;60       {
;;;61     	/* Port 1 */
;;;62     	NVIC_DisableIRQ(UART1_IRQn);
000024  2006              MOVS     r0,#6
000026  f7fffffe          BL       NVIC_DisableIRQ
;;;63     	LPC_PINCON->PINSEL4 &= ~0x0000000F;
00002a  4806              LDR      r0,|L10.68|
00002c  6900              LDR      r0,[r0,#0x10]
00002e  f020000f          BIC      r0,r0,#0xf
000032  4904              LDR      r1,|L10.68|
000034  6108              STR      r0,[r1,#0x10]
;;;64     	LPC_PINCON->PINSEL4 |= 0x0000000A;    /* Enable RxD1 P2.1, TxD1 P2.0 */
000036  4608              MOV      r0,r1
000038  6900              LDR      r0,[r0,#0x10]
00003a  f040000a          ORR      r0,r0,#0xa
00003e  6108              STR      r0,[r1,#0x10]
                  |L10.64|
;;;65       }
;;;66       return;
;;;67     }
000040  bd10              POP      {r4,pc}
;;;68     
                          ENDP

000042  0000              DCW      0x0000
                  |L10.68|
                          DCD      0x4002c000

                          AREA ||i.ser_Read||, CODE, READONLY, ALIGN=2

                  ser_Read PROC
;;;284     *---------------------------------------------------------------------------*/
;;;285    int ser_Read (char *buffer, const int *length) {
000000  b570              PUSH     {r4-r6,lr}
000002  4602              MOV      r2,r0
;;;286      int bytesToRead, bytesRead;
;;;287    
;;;288      /* Read *length bytes, block if *bytes are not avaialable	*/
;;;289      bytesToRead = *length;
000004  680b              LDR      r3,[r1,#0]
;;;290      bytesToRead = (bytesToRead < (*length)) ? bytesToRead : (*length);
000006  680c              LDR      r4,[r1,#0]
000008  429c              CMP      r4,r3
00000a  dd01              BLE      |L11.16|
00000c  461c              MOV      r4,r3
00000e  e000              B        |L11.18|
                  |L11.16|
000010  680c              LDR      r4,[r1,#0]
                  |L11.18|
000012  4623              MOV      r3,r4
;;;291      bytesRead = bytesToRead;
000014  4618              MOV      r0,r3
;;;292    
;;;293      while (bytesToRead--) {
000016  e017              B        |L11.72|
                  |L11.24|
;;;294        while (SER_BUF_EMPTY(ser_in));                     // Block until data is available if none
000018  bf00              NOP      
                  |L11.26|
00001a  4c0e              LDR      r4,|L11.84|
00001c  f8d44084          LDR      r4,[r4,#0x84]  ; ser_in
000020  4d0c              LDR      r5,|L11.84|
000022  f8d55080          LDR      r5,[r5,#0x80]  ; ser_in
000026  42ac              CMP      r4,r5
000028  d0f7              BEQ      |L11.26|
;;;295        *buffer++ = SER_BUF_RD(ser_in);
00002a  4c0a              LDR      r4,|L11.84|
00002c  f8945084          LDRB     r5,[r4,#0x84]  ; ser_in
000030  f8d44084          LDR      r4,[r4,#0x84]  ; ser_in
000034  1c64              ADDS     r4,r4,#1
000036  4e07              LDR      r6,|L11.84|
000038  f8c64084          STR      r4,[r6,#0x84]  ; ser_in
00003c  f005047f          AND      r4,r5,#0x7f
000040  4635              MOV      r5,r6
000042  5d2c              LDRB     r4,[r5,r4]
000044  f8024b01          STRB     r4,[r2],#1
                  |L11.72|
000048  1e1c              SUBS     r4,r3,#0              ;293
00004a  f1a30301          SUB      r3,r3,#1              ;293
00004e  d1e3              BNE      |L11.24|
;;;296      }
;;;297      return (bytesRead);
;;;298    }
000050  bd70              POP      {r4-r6,pc}
;;;299    
                          ENDP

000052  0000              DCW      0x0000
                  |L11.84|
                          DCD      ser_in

                          AREA ||i.ser_Write||, CODE, READONLY, ALIGN=2

                  ser_Write PROC
;;;302     *---------------------------------------------------------------------------*/
;;;303    int ser_Write (char portNum, const char *buffer, int *length) {
000000  b5f0              PUSH     {r4-r7,lr}
000002  4603              MOV      r3,r0
000004  4614              MOV      r4,r2
;;;304      int  bytesToWrite, bytesWritten;
;;;305    
;;;306      // Write *length bytes
;;;307      bytesToWrite = *length;
000006  6822              LDR      r2,[r4,#0]
;;;308      bytesWritten = bytesToWrite;
000008  4610              MOV      r0,r2
;;;309    
;;;310      while (!SER_BUF_EMPTY(ser_out));               // Block until space is available if none
00000a  bf00              NOP      
                  |L12.12|
00000c  4d21              LDR      r5,|L12.148|
00000e  f8d55084          LDR      r5,[r5,#0x84]  ; ser_out
000012  4e20              LDR      r6,|L12.148|
000014  f8d66080          LDR      r6,[r6,#0x80]  ; ser_out
000018  42b5              CMP      r5,r6
00001a  d1f7              BNE      |L12.12|
;;;311      while (bytesToWrite) {
00001c  e010              B        |L12.64|
                  |L12.30|
;;;312          SER_BUF_WR(ser_out, *buffer++);            // Read Rx FIFO to buffer
00001e  f8116b01          LDRB     r6,[r1],#1
000022  4d1c              LDR      r5,|L12.148|
000024  f8957080          LDRB     r7,[r5,#0x80]  ; ser_out
000028  f8d55080          LDR      r5,[r5,#0x80]  ; ser_out
00002c  1c6d              ADDS     r5,r5,#1
00002e  f8dfc064          LDR      r12,|L12.148|
000032  f8cc5080          STR      r5,[r12,#0x80]  ; ser_out
000036  f007057f          AND      r5,r7,#0x7f
00003a  4667              MOV      r7,r12
00003c  557e              STRB     r6,[r7,r5]
;;;313          bytesToWrite--;
00003e  1e52              SUBS     r2,r2,#1
                  |L12.64|
000040  2a00              CMP      r2,#0                 ;311
000042  d1ec              BNE      |L12.30|
;;;314      }
;;;315    
;;;316      if (ser_txRestart) {
000044  4d14              LDR      r5,|L12.152|
000046  682d              LDR      r5,[r5,#0]  ; ser_txRestart
000048  b315              CBZ      r5,|L12.144|
;;;317        ser_txRestart = 0;
00004a  2500              MOVS     r5,#0
00004c  4e12              LDR      r6,|L12.152|
00004e  6035              STR      r5,[r6,#0]  ; ser_txRestart
;;;318    	if ( portNum == 0 )
000050  b97b              CBNZ     r3,|L12.114|
;;;319    	{
;;;320    	  LPC_UART0->THR = SER_BUF_RD(ser_out);             // Write to the Tx Register
000052  4d10              LDR      r5,|L12.148|
000054  f8956084          LDRB     r6,[r5,#0x84]  ; ser_out
000058  f8d55084          LDR      r5,[r5,#0x84]  ; ser_out
00005c  1c6d              ADDS     r5,r5,#1
00005e  4f0d              LDR      r7,|L12.148|
000060  f8c75084          STR      r5,[r7,#0x84]  ; ser_out
000064  f006057f          AND      r5,r6,#0x7f
000068  463e              MOV      r6,r7
00006a  5d75              LDRB     r5,[r6,r5]
00006c  4e0b              LDR      r6,|L12.156|
00006e  7035              STRB     r5,[r6,#0]
000070  e00e              B        |L12.144|
                  |L12.114|
;;;321        }
;;;322    	else
;;;323    	{
;;;324          LPC_UART1->THR = SER_BUF_RD(ser_out);             // Write to the Tx Register
000072  4d08              LDR      r5,|L12.148|
000074  f8956084          LDRB     r6,[r5,#0x84]  ; ser_out
000078  f8d55084          LDR      r5,[r5,#0x84]  ; ser_out
00007c  1c6d              ADDS     r5,r5,#1
00007e  4f05              LDR      r7,|L12.148|
000080  f8c75084          STR      r5,[r7,#0x84]  ; ser_out
000084  f006057f          AND      r5,r6,#0x7f
000088  463e              MOV      r6,r7
00008a  5d75              LDRB     r5,[r6,r5]
00008c  4e04              LDR      r6,|L12.160|
00008e  7035              STRB     r5,[r6,#0]
                  |L12.144|
;;;325    	}
;;;326      }
;;;327    
;;;328      return (bytesWritten);
;;;329    }
000090  bdf0              POP      {r4-r7,pc}
;;;330    
                          ENDP

000092  0000              DCW      0x0000
                  |L12.148|
                          DCD      ser_out
                  |L12.152|
                          DCD      ser_txRestart
                  |L12.156|
                          DCD      0x4000c000
                  |L12.160|
                          DCD      0x40010000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ser_out
                          %        136
                  ser_in
                          %        136

                          AREA ||.data||, DATA, ALIGN=2

                  ser_txRestart
                          DCD      0x00000000
                  ser_lineState
000004  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "Lib\\Usb_Drivers\\Src\\uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f6dc0e52____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___6_uart_c_f6dc0e52____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f6dc0e52____REVSH|
#line 144
|__asm___6_uart_c_f6dc0e52____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
