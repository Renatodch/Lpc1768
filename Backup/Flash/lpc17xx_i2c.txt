; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\lpc17xx_i2c.o --asm_dir=.\Flash\ --list_dir=.\Flash\ --depend=.\flash\lpc17xx_i2c.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\Lib\Drivers\include -I.\Inc -I.\Lib\Usb_Drivers\Inc -I.\Lib\CLib__1_0_0_4\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\NXP\LPC17xx -D__UVISION_VERSION=525 --omf_browse=.\flash\lpc17xx_i2c.crf Lib\Drivers\source\lpc17xx_i2c.c]
                          THUMB

                          AREA ||i.I2C_Cmd||, CODE, READONLY, ALIGN=2

                  I2C_Cmd PROC
;;;365     **********************************************************************/
;;;366    void I2C_Cmd(LPC_I2C_TypeDef* I2Cx, en_I2C_Mode Mode,  FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;367    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;368    	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
000008  b10d              CBZ      r5,|L1.14|
00000a  2d01              CMP      r5,#1
00000c  d100              BNE      |L1.16|
                  |L1.14|
00000e  e004              B        |L1.26|
                  |L1.16|
000010  f44f71b8          MOV      r1,#0x170
000014  a00f              ADR      r0,|L1.84|
000016  f7fffffe          BL       check_failed
                  |L1.26|
;;;369    	CHECK_PARAM(PARAM_I2Cx(I2Cx));
00001a  4817              LDR      r0,|L1.120|
00001c  4284              CMP      r4,r0
00001e  d005              BEQ      |L1.44|
000020  4816              LDR      r0,|L1.124|
000022  4284              CMP      r4,r0
000024  d002              BEQ      |L1.44|
000026  4816              LDR      r0,|L1.128|
000028  4284              CMP      r4,r0
00002a  d100              BNE      |L1.46|
                  |L1.44|
00002c  e004              B        |L1.56|
                  |L1.46|
00002e  f2401171          MOV      r1,#0x171
000032  a008              ADR      r0,|L1.84|
000034  f7fffffe          BL       check_failed
                  |L1.56|
;;;370    
;;;371    	if (NewState == ENABLE)
000038  2d01              CMP      r5,#1
00003a  d107              BNE      |L1.76|
;;;372    	{
;;;373    		if(Mode != I2C_SLAVE_MODE)
00003c  2e01              CMP      r6,#1
00003e  d002              BEQ      |L1.70|
;;;374    			I2Cx->I2CONSET = I2C_I2CONSET_I2EN;
000040  2040              MOVS     r0,#0x40
000042  6020              STR      r0,[r4,#0]
000044  e004              B        |L1.80|
                  |L1.70|
;;;375    		else
;;;376    			I2Cx->I2CONSET = I2C_I2CONSET_I2EN | I2C_I2CONSET_AA;
000046  2044              MOVS     r0,#0x44
000048  6020              STR      r0,[r4,#0]
00004a  e001              B        |L1.80|
                  |L1.76|
;;;377    	}
;;;378    	else
;;;379    	{
;;;380    		I2Cx->I2CONCLR = I2C_I2CONCLR_I2ENC;
00004c  2040              MOVS     r0,#0x40
00004e  61a0              STR      r0,[r4,#0x18]
                  |L1.80|
;;;381    	}
;;;382    }
000050  bd70              POP      {r4-r6,pc}
;;;383    
                          ENDP

000052  0000              DCW      0x0000
                  |L1.84|
000054  4c69625c          DCB      "Lib\\Drivers\\source\\lpc17xx_i2c.c",0
000058  44726976
00005c  6572735c
000060  736f7572
000064  63655c6c
000068  70633137
00006c  78785f69
000070  32632e63
000074  00      
000075  00                DCB      0
000076  00                DCB      0
000077  00                DCB      0
                  |L1.120|
                          DCD      0x4001c000
                  |L1.124|
                          DCD      0x4005c000
                  |L1.128|
                          DCD      0x400a0000

                          AREA ||i.I2C_DeInit||, CODE, READONLY, ALIGN=2

                  I2C_DeInit PROC
;;;332     **********************************************************************/
;;;333    void I2C_DeInit(LPC_I2C_TypeDef* I2Cx)
000000  b510              PUSH     {r4,lr}
;;;334    {
000002  4604              MOV      r4,r0
;;;335    	CHECK_PARAM(PARAM_I2Cx(I2Cx));
000004  4815              LDR      r0,|L2.92|
000006  4284              CMP      r4,r0
000008  d005              BEQ      |L2.22|
00000a  4815              LDR      r0,|L2.96|
00000c  4284              CMP      r4,r0
00000e  d002              BEQ      |L2.22|
000010  4814              LDR      r0,|L2.100|
000012  4284              CMP      r4,r0
000014  d100              BNE      |L2.24|
                  |L2.22|
000016  e004              B        |L2.34|
                  |L2.24|
000018  f240114f          MOV      r1,#0x14f
00001c  a012              ADR      r0,|L2.104|
00001e  f7fffffe          BL       check_failed
                  |L2.34|
;;;336    
;;;337    	/* Disable I2C control */
;;;338    	I2Cx->I2CONCLR = I2C_I2CONCLR_I2ENC;
000022  2040              MOVS     r0,#0x40
000024  61a0              STR      r0,[r4,#0x18]
;;;339    
;;;340    	if (I2Cx==LPC_I2C0)
000026  480d              LDR      r0,|L2.92|
000028  4284              CMP      r4,r0
00002a  d104              BNE      |L2.54|
;;;341    	{
;;;342    		/* Disable power for I2C0 module */
;;;343    		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCI2C0, DISABLE);
00002c  2100              MOVS     r1,#0
00002e  2080              MOVS     r0,#0x80
000030  f7fffffe          BL       CLKPWR_ConfigPPWR
000034  e010              B        |L2.88|
                  |L2.54|
;;;344    	}
;;;345    	else if (I2Cx==LPC_I2C1)
000036  480a              LDR      r0,|L2.96|
000038  4284              CMP      r4,r0
00003a  d105              BNE      |L2.72|
;;;346    	{
;;;347    		/* Disable power for I2C1 module */
;;;348    		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCI2C1, DISABLE);
00003c  2100              MOVS     r1,#0
00003e  f44f2000          MOV      r0,#0x80000
000042  f7fffffe          BL       CLKPWR_ConfigPPWR
000046  e007              B        |L2.88|
                  |L2.72|
;;;349    	}
;;;350    	else if (I2Cx==LPC_I2C2)
000048  4806              LDR      r0,|L2.100|
00004a  4284              CMP      r4,r0
00004c  d104              BNE      |L2.88|
;;;351    	{
;;;352    		/* Disable power for I2C2 module */
;;;353    		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCI2C2, DISABLE);
00004e  2100              MOVS     r1,#0
000050  f04f6080          MOV      r0,#0x4000000
000054  f7fffffe          BL       CLKPWR_ConfigPPWR
                  |L2.88|
;;;354    	}
;;;355    }
000058  bd10              POP      {r4,pc}
;;;356    
                          ENDP

00005a  0000              DCW      0x0000
                  |L2.92|
                          DCD      0x4001c000
                  |L2.96|
                          DCD      0x4005c000
                  |L2.100|
                          DCD      0x400a0000
                  |L2.104|
000068  4c69625c          DCB      "Lib\\Drivers\\source\\lpc17xx_i2c.c",0
00006c  44726976
000070  6572735c
000074  736f7572
000078  63655c6c
00007c  70633137
000080  78785f69
000084  32632e63
000088  00      
000089  00                DCB      0
00008a  00                DCB      0
00008b  00                DCB      0

                          AREA ||i.I2C_GetByte||, CODE, READONLY, ALIGN=1

                  I2C_GetByte PROC
;;;215     *********************************************************************/
;;;216    static uint32_t I2C_GetByte (LPC_I2C_TypeDef *I2Cx, uint8_t *retdat, Bool ack)
000000  4603              MOV      r3,r0
;;;217    {
;;;218    	*retdat = (uint8_t) (I2Cx->I2DAT & I2C_I2DAT_BITMASK);
000002  6898              LDR      r0,[r3,#8]
000004  7008              STRB     r0,[r1,#0]
;;;219    	
;;;220    	if (ack == TRUE)
000006  2a01              CMP      r2,#1
000008  d102              BNE      |L3.16|
;;;221    	{
;;;222    		I2Cx->I2CONSET = I2C_I2CONSET_AA;
00000a  2004              MOVS     r0,#4
00000c  6018              STR      r0,[r3,#0]
00000e  e001              B        |L3.20|
                  |L3.16|
;;;223    	}
;;;224    	else
;;;225    	{
;;;226    		I2Cx->I2CONCLR = I2C_I2CONCLR_AAC;
000010  2004              MOVS     r0,#4
000012  6198              STR      r0,[r3,#0x18]
                  |L3.20|
;;;227    	}
;;;228    
;;;229    	I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
000014  2008              MOVS     r0,#8
000016  6198              STR      r0,[r3,#0x18]
;;;230    	
;;;231    	return (I2Cx->I2STAT & I2C_STAT_CODE_BITMASK);
000018  6858              LDR      r0,[r3,#4]
00001a  f00000f8          AND      r0,r0,#0xf8
;;;232    }
00001e  4770              BX       lr
;;;233    
                          ENDP


                          AREA ||i.I2C_Init||, CODE, READONLY, ALIGN=2

                  I2C_Init PROC
;;;284     *********************************************************************/
;;;285    void I2C_Init(LPC_I2C_TypeDef *I2Cx, uint32_t clockrate)
000000  b570              PUSH     {r4-r6,lr}
;;;286    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;287    	CHECK_PARAM(PARAM_I2Cx(I2Cx));
000006  481e              LDR      r0,|L4.128|
000008  4284              CMP      r4,r0
00000a  d005              BEQ      |L4.24|
00000c  481d              LDR      r0,|L4.132|
00000e  4284              CMP      r4,r0
000010  d002              BEQ      |L4.24|
000012  481d              LDR      r0,|L4.136|
000014  4284              CMP      r4,r0
000016  d100              BNE      |L4.26|
                  |L4.24|
000018  e004              B        |L4.36|
                  |L4.26|
00001a  f240111f          MOV      r1,#0x11f
00001e  a01b              ADR      r0,|L4.140|
000020  f7fffffe          BL       check_failed
                  |L4.36|
;;;288    
;;;289    	if (I2Cx==LPC_I2C0)
000024  4816              LDR      r0,|L4.128|
000026  4284              CMP      r4,r0
000028  d108              BNE      |L4.60|
;;;290    	{
;;;291    		/* Set up clock and power for I2C0 module */
;;;292    		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCI2C0, ENABLE);
00002a  2101              MOVS     r1,#1
00002c  2080              MOVS     r0,#0x80
00002e  f7fffffe          BL       CLKPWR_ConfigPPWR
;;;293    		/* As default, peripheral clock for I2C0 module
;;;294    		 * is set to FCCLK / 2 */
;;;295    		CLKPWR_SetPCLKDiv(CLKPWR_PCLKSEL_I2C0, CLKPWR_PCLKSEL_CCLK_DIV_2);
000032  2102              MOVS     r1,#2
000034  200e              MOVS     r0,#0xe
000036  f7fffffe          BL       CLKPWR_SetPCLKDiv
00003a  e018              B        |L4.110|
                  |L4.60|
;;;296    	}
;;;297    	else if (I2Cx==LPC_I2C1)
00003c  4811              LDR      r0,|L4.132|
00003e  4284              CMP      r4,r0
000040  d108              BNE      |L4.84|
;;;298    	{
;;;299    		/* Set up clock and power for I2C1 module */
;;;300    		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCI2C1, ENABLE);
000042  2101              MOVS     r1,#1
000044  04c8              LSLS     r0,r1,#19
000046  f7fffffe          BL       CLKPWR_ConfigPPWR
;;;301    		/* As default, peripheral clock for I2C1 module
;;;302    		 * is set to FCCLK / 2 */
;;;303    		CLKPWR_SetPCLKDiv(CLKPWR_PCLKSEL_I2C1, CLKPWR_PCLKSEL_CCLK_DIV_2);
00004a  2102              MOVS     r1,#2
00004c  2026              MOVS     r0,#0x26
00004e  f7fffffe          BL       CLKPWR_SetPCLKDiv
000052  e00c              B        |L4.110|
                  |L4.84|
;;;304    	}
;;;305    	else if (I2Cx==LPC_I2C2)
000054  480c              LDR      r0,|L4.136|
000056  4284              CMP      r4,r0
000058  d108              BNE      |L4.108|
;;;306    	{
;;;307    		/* Set up clock and power for I2C2 module */
;;;308    		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCI2C2, ENABLE);
00005a  2101              MOVS     r1,#1
00005c  0688              LSLS     r0,r1,#26
00005e  f7fffffe          BL       CLKPWR_ConfigPPWR
;;;309    		/* As default, peripheral clock for I2C2 module
;;;310    		 * is set to FCCLK / 2 */
;;;311    		CLKPWR_SetPCLKDiv(CLKPWR_PCLKSEL_I2C2, CLKPWR_PCLKSEL_CCLK_DIV_2);
000062  2102              MOVS     r1,#2
000064  2034              MOVS     r0,#0x34
000066  f7fffffe          BL       CLKPWR_SetPCLKDiv
00006a  e000              B        |L4.110|
                  |L4.108|
;;;312    	}
;;;313    	else {
;;;314    		// Up-Support this device
;;;315    		return;
;;;316    	}
;;;317    
;;;318        /* Set clock rate */
;;;319        I2C_SetClock(I2Cx, clockrate);
;;;320        /* Set I2C operation to default */
;;;321        I2Cx->I2CONCLR = (I2C_I2CONCLR_AAC | I2C_I2CONCLR_STAC | I2C_I2CONCLR_I2ENC);
;;;322    }
00006c  bd70              POP      {r4-r6,pc}
                  |L4.110|
00006e  4629              MOV      r1,r5                 ;319
000070  4620              MOV      r0,r4                 ;319
000072  f7fffffe          BL       I2C_SetClock
000076  2064              MOVS     r0,#0x64              ;321
000078  61a0              STR      r0,[r4,#0x18]         ;321
00007a  bf00              NOP      
00007c  e7f6              B        |L4.108|
;;;323    
                          ENDP

00007e  0000              DCW      0x0000
                  |L4.128|
                          DCD      0x4001c000
                  |L4.132|
                          DCD      0x4005c000
                  |L4.136|
                          DCD      0x400a0000
                  |L4.140|
00008c  4c69625c          DCB      "Lib\\Drivers\\source\\lpc17xx_i2c.c",0
000090  44726976
000094  6572735c
000098  736f7572
00009c  63655c6c
0000a0  70633137
0000a4  78785f69
0000a8  32632e63
0000ac  00      
0000ad  00                DCB      0
0000ae  00                DCB      0
0000af  00                DCB      0

                          AREA ||i.I2C_IntCmd||, CODE, READONLY, ALIGN=2

                  I2C_IntCmd PROC
;;;395     **********************************************************************/
;;;396    void I2C_IntCmd (LPC_I2C_TypeDef *I2Cx, Bool NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;397    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;398    	if (NewState)
000006  b1a5              CBZ      r5,|L5.50|
;;;399    	{
;;;400    		if(I2Cx == LPC_I2C0)
000008  4814              LDR      r0,|L5.92|
00000a  4284              CMP      r4,r0
00000c  d103              BNE      |L5.22|
;;;401    		{
;;;402    			NVIC_EnableIRQ(I2C0_IRQn);
00000e  200a              MOVS     r0,#0xa
000010  f7fffffe          BL       NVIC_EnableIRQ
000014  e021              B        |L5.90|
                  |L5.22|
;;;403    		}
;;;404    		else if (I2Cx == LPC_I2C1)
000016  4812              LDR      r0,|L5.96|
000018  4284              CMP      r4,r0
00001a  d103              BNE      |L5.36|
;;;405    		{
;;;406    			NVIC_EnableIRQ(I2C1_IRQn);
00001c  200b              MOVS     r0,#0xb
00001e  f7fffffe          BL       NVIC_EnableIRQ
000022  e01a              B        |L5.90|
                  |L5.36|
;;;407    		}
;;;408    		else if (I2Cx == LPC_I2C2)
000024  480f              LDR      r0,|L5.100|
000026  4284              CMP      r4,r0
000028  d117              BNE      |L5.90|
;;;409    		{
;;;410    			NVIC_EnableIRQ(I2C2_IRQn);
00002a  200c              MOVS     r0,#0xc
00002c  f7fffffe          BL       NVIC_EnableIRQ
000030  e013              B        |L5.90|
                  |L5.50|
;;;411    		}
;;;412    	}
;;;413    	else
;;;414    	{
;;;415    		if(I2Cx == LPC_I2C0)
000032  480a              LDR      r0,|L5.92|
000034  4284              CMP      r4,r0
000036  d103              BNE      |L5.64|
;;;416    		{
;;;417    			NVIC_DisableIRQ(I2C0_IRQn);
000038  200a              MOVS     r0,#0xa
00003a  f7fffffe          BL       NVIC_DisableIRQ
00003e  e00c              B        |L5.90|
                  |L5.64|
;;;418    		}
;;;419    		else if (I2Cx == LPC_I2C1)
000040  4807              LDR      r0,|L5.96|
000042  4284              CMP      r4,r0
000044  d103              BNE      |L5.78|
;;;420    		{
;;;421    			NVIC_DisableIRQ(I2C1_IRQn);
000046  200b              MOVS     r0,#0xb
000048  f7fffffe          BL       NVIC_DisableIRQ
00004c  e005              B        |L5.90|
                  |L5.78|
;;;422    		}
;;;423    		else if (I2Cx == LPC_I2C2)
00004e  4805              LDR      r0,|L5.100|
000050  4284              CMP      r4,r0
000052  d102              BNE      |L5.90|
;;;424    		{
;;;425    			NVIC_DisableIRQ(I2C2_IRQn);
000054  200c              MOVS     r0,#0xc
000056  f7fffffe          BL       NVIC_DisableIRQ
                  |L5.90|
;;;426    		}
;;;427    	}
;;;428        return;
;;;429    }
00005a  bd70              POP      {r4-r6,pc}
;;;430    
                          ENDP

                  |L5.92|
                          DCD      0x4001c000
                  |L5.96|
                          DCD      0x4005c000
                  |L5.100|
                          DCD      0x400a0000

                          AREA ||i.I2C_MasterHandler||, CODE, READONLY, ALIGN=2

                  I2C_MasterHandler PROC
;;;752     **********************************************************************/
;;;753    void I2C_MasterHandler(LPC_I2C_TypeDef  *I2Cx)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;754    {
000004  4605              MOV      r5,r0
;;;755    	uint32_t i2cId = I2C_getNum(I2Cx);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       I2C_getNum
00000c  4607              MOV      r7,r0
;;;756    	uint8_t returnCode;
;;;757    	I2C_M_SETUP_Type *txrx_setup;
;;;758    	int32_t Ret = I2C_OK;
00000e  2600              MOVS     r6,#0
;;;759    
;;;760    	txrx_setup = (I2C_M_SETUP_Type *) i2cdat[i2cId].txrx_setup;
000010  481f              LDR      r0,|L6.144|
000012  f8504037          LDR      r4,[r0,r7,LSL #3]
;;;761    
;;;762    	returnCode = (I2Cx->I2STAT & I2C_STAT_CODE_BITMASK);
000016  6868              LDR      r0,[r5,#4]
000018  f00008f8          AND      r8,r0,#0xf8
;;;763    
;;;764    	// Save current status
;;;765    	txrx_setup->status = returnCode;
00001c  f8c48024          STR      r8,[r4,#0x24]
;;;766    
;;;767    	Ret = I2C_MasterHanleStates(I2Cx, returnCode, txrx_setup);
000020  4622              MOV      r2,r4
000022  4641              MOV      r1,r8
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       I2C_MasterHanleStates
00002a  4606              MOV      r6,r0
;;;768    
;;;769    	if(I2C_CheckError(Ret))
00002c  f0065080          AND      r0,r6,#0x10000000
000030  b180              CBZ      r0,|L6.84|
;;;770    	{
;;;771    		if(txrx_setup->retransmissions_count < txrx_setup->retransmissions_max)
000032  e9d41007          LDRD     r1,r0,[r4,#0x1c]
000036  4288              CMP      r0,r1
000038  d20b              BCS      |L6.82|
;;;772    		{
;;;773    			// Retry
;;;774    			txrx_setup->retransmissions_count ++;
00003a  6a20              LDR      r0,[r4,#0x20]
00003c  1c40              ADDS     r0,r0,#1
00003e  6220              STR      r0,[r4,#0x20]
;;;775    			txrx_setup->tx_count = 0;
000040  2000              MOVS     r0,#0
000042  60e0              STR      r0,[r4,#0xc]
;;;776    			txrx_setup->rx_count = 0;
000044  61a0              STR      r0,[r4,#0x18]
;;;777    			// Reset STA, STO, SI
;;;778    	        I2Cx->I2CONCLR = I2C_I2CONCLR_SIC|I2C_I2CONCLR_STOC|I2C_I2CONCLR_STAC;
000046  2038              MOVS     r0,#0x38
000048  61a8              STR      r0,[r5,#0x18]
;;;779    			I2Cx->I2CONSET = I2C_I2CONSET_STA;
00004a  2020              MOVS     r0,#0x20
00004c  6028              STR      r0,[r5,#0]
                  |L6.78|
;;;780    			return;
;;;781    		}
;;;782    		else
;;;783    		{
;;;784    			goto s_int_end;
;;;785    		}
;;;786    	}
;;;787    	else if (Ret & I2C_SEND_END)
;;;788    	{
;;;789    		// If no need to wait for data from Slave
;;;790    		if(txrx_setup->rx_count >= (txrx_setup->rx_length)) 
;;;791    		{
;;;792    			goto s_int_end;
;;;793    		}
;;;794    		else	// Start to wait for data from Slave
;;;795    		{
;;;796    			// Reset STA, STO, SI
;;;797    	       		I2Cx->I2CONCLR = I2C_I2CONCLR_SIC|I2C_I2CONCLR_STOC|I2C_I2CONCLR_STAC;
;;;798    	       		I2Cx->I2CONSET = I2C_I2CONSET_STA;
;;;799    	       		return;
;;;800    		}
;;;801    	}
;;;802    	else if (Ret & I2C_RECV_END) 
;;;803    	{
;;;804    		goto s_int_end;
;;;805    	}
;;;806    	else
;;;807    	{
;;;808    		return;
;;;809    	}
;;;810    
;;;811    s_int_end:
;;;812    	// Disable interrupt
;;;813    	I2C_IntCmd(I2Cx, FALSE);
;;;814    
;;;815    	I2Cx->I2CONCLR = I2C_I2CONCLR_AAC | I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC;
;;;816    
;;;817    	I2C_MasterComplete[i2cId] = TRUE;
;;;818    		
;;;819    }
00004e  e8bd81f0          POP      {r4-r8,pc}
                  |L6.82|
000052  e011              B        |L6.120|
                  |L6.84|
000054  f0060008          AND      r0,r6,#8              ;787
000058  b148              CBZ      r0,|L6.110|
00005a  69a0              LDR      r0,[r4,#0x18]         ;790
00005c  6961              LDR      r1,[r4,#0x14]         ;790
00005e  4288              CMP      r0,r1                 ;790
000060  d300              BCC      |L6.100|
000062  e009              B        |L6.120|
                  |L6.100|
000064  2038              MOVS     r0,#0x38              ;797
000066  61a8              STR      r0,[r5,#0x18]         ;797
000068  2020              MOVS     r0,#0x20              ;798
00006a  6028              STR      r0,[r5,#0]            ;798
00006c  e7ef              B        |L6.78|
                  |L6.110|
00006e  f0060010          AND      r0,r6,#0x10           ;802
000072  b100              CBZ      r0,|L6.118|
000074  e000              B        |L6.120|
                  |L6.118|
000076  e7ea              B        |L6.78|
                  |L6.120|
000078  2100              MOVS     r1,#0                 ;813
00007a  4628              MOV      r0,r5                 ;813
00007c  f7fffffe          BL       I2C_IntCmd
000080  202c              MOVS     r0,#0x2c              ;815
000082  61a8              STR      r0,[r5,#0x18]         ;815
000084  2001              MOVS     r0,#1                 ;817
000086  4903              LDR      r1,|L6.148|
000088  f8410027          STR      r0,[r1,r7,LSL #2]     ;817
00008c  bf00              NOP      
00008e  e7de              B        |L6.78|
;;;820    
                          ENDP

                  |L6.144|
                          DCD      i2cdat
                  |L6.148|
                          DCD      I2C_MasterComplete

                          AREA ||i.I2C_MasterHanleStates||, CODE, READONLY, ALIGN=1

                  I2C_MasterHanleStates PROC
;;;450     **********************************************************************/
;;;451    int32_t I2C_MasterHanleStates(LPC_I2C_TypeDef  *I2Cx, uint32_t CodeStatus, I2C_M_SETUP_Type *TransferCfg)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;452    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;453    	uint8_t *txdat;
;;;454    	uint8_t *rxdat;
;;;455    	uint8_t tmp;
;;;456    	int32_t Ret = I2C_OK;
00000a  f04f0900          MOV      r9,#0
;;;457    	
;;;458    	//get buffer to send/receive
;;;459    	txdat = (uint8_t *) &TransferCfg->tx_data[TransferCfg->tx_count];
00000e  68e1              LDR      r1,[r4,#0xc]
000010  6860              LDR      r0,[r4,#4]
000012  eb000801          ADD      r8,r0,r1
;;;460    	rxdat = (uint8_t *) &TransferCfg->rx_data[TransferCfg->rx_count];
000016  69a1              LDR      r1,[r4,#0x18]
000018  6920              LDR      r0,[r4,#0x10]
00001a  1846              ADDS     r6,r0,r1
;;;461    
;;;462    	switch(CodeStatus)
00001c  2f30              CMP      r7,#0x30
00001e  d053              BEQ      |L7.200|
000020  dc0e              BGT      |L7.64|
000022  2f18              CMP      r7,#0x18
000024  d038              BEQ      |L7.152|
000026  dc06              BGT      |L7.54|
000028  2f00              CMP      r7,#0
00002a  d070              BEQ      |L7.270|
00002c  2f08              CMP      r7,#8
00002e  d016              BEQ      |L7.94|
000030  2f10              CMP      r7,#0x10
                  |L7.50|
000032  d16d              BNE      |L7.272|
000034  e014              B        |L7.96|
                  |L7.54|
000036  2f20              CMP      r7,#0x20
000038  d06b              BEQ      |L7.274|
00003a  2f28              CMP      r7,#0x28
00003c  d1f9              BNE      |L7.50|
00003e  e02c              B        |L7.154|
                  |L7.64|
000040  2f50              CMP      r7,#0x50
000042  d053              BEQ      |L7.236|
000044  dc06              BGT      |L7.84|
000046  2f38              CMP      r7,#0x38
000048  d044              BEQ      |L7.212|
00004a  2f40              CMP      r7,#0x40
00004c  d047              BEQ      |L7.222|
00004e  2f48              CMP      r7,#0x48
000050  d1ef              BNE      |L7.50|
000052  e084              B        |L7.350|
                  |L7.84|
000054  2f58              CMP      r7,#0x58
000056  d070              BEQ      |L7.314|
000058  2ff8              CMP      r7,#0xf8
00005a  d1ea              BNE      |L7.50|
00005c  e088              B        |L7.368|
                  |L7.94|
;;;463    	{
;;;464    		case I2C_I2STAT_M_TX_START:
;;;465    		case I2C_I2STAT_M_TX_RESTART:
00005e  bf00              NOP      
                  |L7.96|
;;;466    		//case I2C_I2STAT_M_RX_START:
;;;467    		//case I2C_I2STAT_M_RX_RESTART
;;;468    			// Send data first
;;;469    			if(TransferCfg->tx_count < TransferCfg->tx_length)
000060  68e0              LDR      r0,[r4,#0xc]
000062  68a1              LDR      r1,[r4,#8]
000064  4288              CMP      r0,r1
000066  d208              BCS      |L7.122|
;;;470    			{
;;;471    				/* Send slave address + WR direction bit = 0 ----------------------------------- */
;;;472    				I2C_SendByte(I2Cx, (TransferCfg->sl_addr7bit << 1));
000068  7820              LDRB     r0,[r4,#0]
00006a  0640              LSLS     r0,r0,#25
00006c  0e01              LSRS     r1,r0,#24
00006e  4628              MOV      r0,r5
000070  f7fffffe          BL       I2C_SendByte
;;;473    				Ret = I2C_BYTE_SENT;
000074  f04f0901          MOV      r9,#1
000078  e00d              B        |L7.150|
                  |L7.122|
;;;474    			}
;;;475    			else if (TransferCfg->rx_count  < TransferCfg->rx_length)
00007a  69a0              LDR      r0,[r4,#0x18]
00007c  6961              LDR      r1,[r4,#0x14]
00007e  4288              CMP      r0,r1
000080  d209              BCS      |L7.150|
;;;476    			{
;;;477    				/* Send slave address + RD direction bit = 1 ----------------------------------- */
;;;478    				I2C_SendByte(I2Cx, ((TransferCfg->sl_addr7bit << 1) | 0x01));
000082  7820              LDRB     r0,[r4,#0]
000084  2201              MOVS     r2,#1
000086  eb020040          ADD      r0,r2,r0,LSL #1
00008a  b2c1              UXTB     r1,r0
00008c  4628              MOV      r0,r5
00008e  f7fffffe          BL       I2C_SendByte
;;;479    				Ret = I2C_BYTE_SENT;
000092  f04f0901          MOV      r9,#1
                  |L7.150|
;;;480    			}
;;;481    			break;
000096  e06e              B        |L7.374|
                  |L7.152|
;;;482    		case I2C_I2STAT_M_TX_SLAW_ACK:
;;;483    		case I2C_I2STAT_M_TX_DAT_ACK:
000098  bf00              NOP      
                  |L7.154|
;;;484    			
;;;485    			if(TransferCfg->tx_count < TransferCfg->tx_length)
00009a  68e0              LDR      r0,[r4,#0xc]
00009c  68a1              LDR      r1,[r4,#8]
00009e  4288              CMP      r0,r1
0000a0  d20c              BCS      |L7.188|
;;;486    			{
;;;487    				I2C_SendByte(I2Cx, *txdat);
0000a2  f8981000          LDRB     r1,[r8,#0]
0000a6  4628              MOV      r0,r5
0000a8  f7fffffe          BL       I2C_SendByte
;;;488    				
;;;489    				txdat++;
0000ac  f1080801          ADD      r8,r8,#1
;;;490    
;;;491    				TransferCfg->tx_count++;
0000b0  68e0              LDR      r0,[r4,#0xc]
0000b2  1c40              ADDS     r0,r0,#1
0000b4  60e0              STR      r0,[r4,#0xc]
;;;492    
;;;493    				Ret = I2C_BYTE_SENT;
0000b6  f04f0901          MOV      r9,#1
0000ba  e004              B        |L7.198|
                  |L7.188|
;;;494    			}
;;;495    			else
;;;496    			{
;;;497    				I2C_Stop(I2Cx);
0000bc  4628              MOV      r0,r5
0000be  f7fffffe          BL       I2C_Stop
;;;498    
;;;499    				Ret = I2C_SEND_END;
0000c2  f04f0908          MOV      r9,#8
                  |L7.198|
;;;500    				
;;;501    			}
;;;502    			break;
0000c6  e056              B        |L7.374|
                  |L7.200|
;;;503    		case I2C_I2STAT_M_TX_DAT_NACK:
;;;504    			I2C_Stop(I2Cx);
0000c8  4628              MOV      r0,r5
0000ca  f7fffffe          BL       I2C_Stop
;;;505    			Ret = I2C_SEND_END;
0000ce  f04f0908          MOV      r9,#8
;;;506    			break;
0000d2  e050              B        |L7.374|
                  |L7.212|
;;;507    		case I2C_I2STAT_M_RX_ARB_LOST:
;;;508    		//case I2C_I2STAT_M_TX_ARB_LOST:
;;;509    			I2Cx->I2CONSET = I2C_I2CONSET_STA|I2C_I2CONSET_AA;
0000d4  2024              MOVS     r0,#0x24
0000d6  6028              STR      r0,[r5,#0]
;;;510    			I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
0000d8  2008              MOVS     r0,#8
0000da  61a8              STR      r0,[r5,#0x18]
;;;511    			break;
0000dc  e04b              B        |L7.374|
                  |L7.222|
;;;512    		case I2C_I2STAT_M_RX_SLAR_ACK:
;;;513    			I2Cx->I2CONSET = I2C_I2CONSET_AA;
0000de  2004              MOVS     r0,#4
0000e0  6028              STR      r0,[r5,#0]
;;;514    			I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
0000e2  2008              MOVS     r0,#8
0000e4  61a8              STR      r0,[r5,#0x18]
;;;515    
;;;516    			Ret = I2C_BYTE_RECV;
0000e6  f04f0902          MOV      r9,#2
;;;517    			break;
0000ea  e044              B        |L7.374|
                  |L7.236|
;;;518    		case I2C_I2STAT_M_RX_DAT_ACK:
;;;519    			if (TransferCfg->rx_count <TransferCfg->rx_length)
0000ec  69a0              LDR      r0,[r4,#0x18]
0000ee  6961              LDR      r1,[r4,#0x14]
0000f0  4288              CMP      r0,r1
0000f2  d21e              BCS      |L7.306|
;;;520    			{
;;;521    				if (TransferCfg->rx_count < (TransferCfg->rx_length - 2))
0000f4  69a1              LDR      r1,[r4,#0x18]
0000f6  6960              LDR      r0,[r4,#0x14]
0000f8  1e80              SUBS     r0,r0,#2
0000fa  4281              CMP      r1,r0
0000fc  d20a              BCS      |L7.276|
;;;522    				{
;;;523    					I2C_GetByte(I2Cx, &tmp, TRUE);
0000fe  2201              MOVS     r2,#1
000100  4669              MOV      r1,sp
000102  4628              MOV      r0,r5
000104  f7fffffe          BL       I2C_GetByte
;;;524    
;;;525    					Ret = I2C_BYTE_RECV;
000108  f04f0902          MOV      r9,#2
00010c  e009              B        |L7.290|
                  |L7.270|
00010e  e028              B        |L7.354|
                  |L7.272|
000110  e02d              B        |L7.366|
                  |L7.274|
000112  e025              B        |L7.352|
                  |L7.276|
;;;526    				}
;;;527    				else  // the next byte is the last byte, send NACK instead.
;;;528    				 {
;;;529    					I2C_GetByte(I2Cx, &tmp, FALSE);
000114  2200              MOVS     r2,#0
000116  4669              MOV      r1,sp
000118  4628              MOV      r0,r5
00011a  f7fffffe          BL       I2C_GetByte
;;;530    					Ret = I2C_BYTE_RECV;
00011e  f04f0902          MOV      r9,#2
                  |L7.290|
;;;531    				 }
;;;532    				*rxdat++ = tmp;
000122  f89d0000          LDRB     r0,[sp,#0]
000126  f8060b01          STRB     r0,[r6],#1
;;;533    
;;;534    				TransferCfg->rx_count++;
00012a  69a0              LDR      r0,[r4,#0x18]
00012c  1c40              ADDS     r0,r0,#1
00012e  61a0              STR      r0,[r4,#0x18]
000130  e001              B        |L7.310|
                  |L7.306|
;;;535    			}
;;;536    			 else
;;;537    			 {
;;;538    				Ret = I2C_RECV_END;
000132  f04f0910          MOV      r9,#0x10
                  |L7.310|
;;;539    			}
;;;540    			
;;;541    			break;
000136  e01e              B        |L7.374|
000138  e7ff              B        |L7.314|
                  |L7.314|
;;;542    		case I2C_I2STAT_M_RX_DAT_NACK:
;;;543    			I2C_GetByte(I2Cx, &tmp, FALSE);
00013a  2200              MOVS     r2,#0
00013c  4669              MOV      r1,sp
00013e  4628              MOV      r0,r5
000140  f7fffffe          BL       I2C_GetByte
;;;544    			*rxdat++ = tmp;
000144  f89d0000          LDRB     r0,[sp,#0]
000148  f8060b01          STRB     r0,[r6],#1
;;;545    			TransferCfg->rx_count++;
00014c  69a0              LDR      r0,[r4,#0x18]
00014e  1c40              ADDS     r0,r0,#1
000150  61a0              STR      r0,[r4,#0x18]
;;;546    			I2C_Stop(I2Cx);
000152  4628              MOV      r0,r5
000154  f7fffffe          BL       I2C_Stop
;;;547    			Ret = I2C_RECV_END;
000158  f04f0910          MOV      r9,#0x10
;;;548    			break;
00015c  e00b              B        |L7.374|
                  |L7.350|
;;;549    		case I2C_I2STAT_M_RX_SLAR_NACK:
;;;550    		case I2C_I2STAT_M_TX_SLAW_NACK:
00015e  bf00              NOP      
                  |L7.352|
;;;551    		case I2C_I2STAT_BUS_ERROR:
000160  bf00              NOP      
                  |L7.354|
;;;552    			// Send STOP condition
;;;553    			I2C_Stop(I2Cx);
000162  4628              MOV      r0,r5
000164  f7fffffe          BL       I2C_Stop
;;;554    			Ret = I2C_ERR;
000168  f04f5980          MOV      r9,#0x10000000
;;;555    			break;
00016c  e003              B        |L7.374|
                  |L7.366|
;;;556    		/* No status information */
;;;557    		case I2C_I2STAT_NO_INF:
00016e  bf00              NOP      
                  |L7.368|
;;;558    		default:
;;;559    			I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
000170  2008              MOVS     r0,#8
000172  61a8              STR      r0,[r5,#0x18]
;;;560    			break;
000174  bf00              NOP      
                  |L7.374|
000176  bf00              NOP                            ;481
;;;561    	}
;;;562    	
;;;563    	return Ret;
000178  4648              MOV      r0,r9
;;;564    }
00017a  e8bd83f8          POP      {r3-r9,pc}
;;;565    
                          ENDP


                          AREA ||i.I2C_MasterTransferComplete||, CODE, READONLY, ALIGN=2

                  I2C_MasterTransferComplete PROC
;;;1305    **********************************************************************/
;;;1306   uint32_t I2C_MasterTransferComplete(LPC_I2C_TypeDef *I2Cx)
000000  b570              PUSH     {r4-r6,lr}
;;;1307   {
000002  4605              MOV      r5,r0
;;;1308   	uint32_t retval, tmp;
;;;1309   	tmp = I2C_getNum(I2Cx);
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       I2C_getNum
00000a  4604              MOV      r4,r0
;;;1310   	retval = I2C_MasterComplete[tmp];
00000c  4804              LDR      r0,|L8.32|
00000e  f8506024          LDR      r6,[r0,r4,LSL #2]
;;;1311   	I2C_MasterComplete[tmp] = FALSE;
000012  2000              MOVS     r0,#0
000014  4902              LDR      r1,|L8.32|
000016  f8410024          STR      r0,[r1,r4,LSL #2]
;;;1312   	return retval;
00001a  4630              MOV      r0,r6
;;;1313   }
00001c  bd70              POP      {r4-r6,pc}
;;;1314   
                          ENDP

00001e  0000              DCW      0x0000
                  |L8.32|
                          DCD      I2C_MasterComplete

                          AREA ||i.I2C_MasterTransferData||, CODE, READONLY, ALIGN=2

                  I2C_MasterTransferData PROC
;;;917     **********************************************************************/
;;;918    Status I2C_MasterTransferData(LPC_I2C_TypeDef *I2Cx, I2C_M_SETUP_Type *TransferCfg, \
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;919    																	I2C_TRANSFER_OPT_Type Opt)
;;;920    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
;;;921    	uint32_t i2cId = I2C_getNum(I2Cx);	uint32_t CodeStatus;
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       I2C_getNum
000010  4680              MOV      r8,r0
;;;922    	int32_t Ret = I2C_OK;
000012  2600              MOVS     r6,#0
;;;923    
;;;924    	// Reset I2C setup value to default state
;;;925    	TransferCfg->tx_count = 0;
000014  2000              MOVS     r0,#0
000016  60e0              STR      r0,[r4,#0xc]
;;;926    	TransferCfg->rx_count = 0;
000018  61a0              STR      r0,[r4,#0x18]
;;;927    	TransferCfg->status = 0;
00001a  6260              STR      r0,[r4,#0x24]
;;;928    
;;;929    	if (Opt == I2C_TRANSFER_POLLING)
00001c  2f00              CMP      r7,#0
00001e  d145              BNE      |L9.172|
;;;930    	{
;;;931    		/* First Start condition -------------------------------------------------------------- */
;;;932    		TransferCfg->retransmissions_count = 0;
000020  6220              STR      r0,[r4,#0x20]
;;;933    retry:
000022  bf00              NOP      
                  |L9.36|
;;;934    		// Reset I2C setup value to default state
;;;935    		TransferCfg->tx_count = 0;
000024  2000              MOVS     r0,#0
000026  60e0              STR      r0,[r4,#0xc]
;;;936    		TransferCfg->rx_count = 0;
000028  61a0              STR      r0,[r4,#0x18]
;;;937    
;;;938    		// Start command
;;;939    		CodeStatus = I2C_Start(I2Cx);
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       I2C_Start
000030  4681              MOV      r9,r0
;;;940    		
;;;941    		while(1)	// send data first and then receive data from Slave.
000032  e034              B        |L9.158|
                  |L9.52|
;;;942    		{
;;;943    			Ret = I2C_MasterHanleStates(I2Cx, CodeStatus, TransferCfg);
000034  4622              MOV      r2,r4
000036  4649              MOV      r1,r9
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       I2C_MasterHanleStates
00003e  4606              MOV      r6,r0
;;;944    			if(I2C_CheckError(Ret))
000040  f0065080          AND      r0,r6,#0x10000000
000044  b158              CBZ      r0,|L9.94|
;;;945    			{
;;;946    				TransferCfg->retransmissions_count++;
000046  6a20              LDR      r0,[r4,#0x20]
000048  1c40              ADDS     r0,r0,#1
00004a  6220              STR      r0,[r4,#0x20]
;;;947    				if (TransferCfg->retransmissions_count > TransferCfg->retransmissions_max){
00004c  e9d41007          LDRD     r1,r0,[r4,#0x1c]
000050  4288              CMP      r0,r1
000052  d903              BLS      |L9.92|
;;;948    						// save status
;;;949    						TransferCfg->status = CodeStatus | I2C_SETUP_STATUS_NOACKF;
000054  f4497000          ORR      r0,r9,#0x200
000058  6260              STR      r0,[r4,#0x24]
;;;950    						goto error;
00005a  e025              B        |L9.168|
                  |L9.92|
;;;951    					} else {
;;;952    						goto retry;
00005c  e7e2              B        |L9.36|
                  |L9.94|
;;;953    					}
;;;954    			}
;;;955    			else if( (Ret & I2C_BYTE_SENT) ||
00005e  f0060001          AND      r0,r6,#1
000062  b910              CBNZ     r0,|L9.106|
;;;956    					(Ret & I2C_BYTE_RECV))
000064  f0060002          AND      r0,r6,#2
000068  b130              CBZ      r0,|L9.120|
                  |L9.106|
;;;957    			{
;;;958    				// Wait for sending ends				
;;;959    				while (!(I2Cx->I2CONSET & I2C_I2CONSET_SI));
00006a  bf00              NOP      
                  |L9.108|
00006c  6828              LDR      r0,[r5,#0]
00006e  f0000008          AND      r0,r0,#8
000072  2800              CMP      r0,#0
000074  d0fa              BEQ      |L9.108|
000076  e00f              B        |L9.152|
                  |L9.120|
;;;960    			}
;;;961    			else if (Ret & I2C_SEND_END) // already send all data
000078  f0060008          AND      r0,r6,#8
00007c  b140              CBZ      r0,|L9.144|
;;;962    			{
;;;963    				// If no need to wait for data from Slave
;;;964    				if(TransferCfg->rx_count >= (TransferCfg->rx_length)) 
00007e  69a0              LDR      r0,[r4,#0x18]
000080  6961              LDR      r1,[r4,#0x14]
000082  4288              CMP      r0,r1
000084  d300              BCC      |L9.136|
;;;965    				{
;;;966    					break;
000086  e00b              B        |L9.160|
                  |L9.136|
;;;967    				}
;;;968    				else
;;;969    				{
;;;970    					I2C_Start(I2Cx);
000088  4628              MOV      r0,r5
00008a  f7fffffe          BL       I2C_Start
00008e  e003              B        |L9.152|
                  |L9.144|
;;;971    				}
;;;972    			}
;;;973    			else if (Ret & I2C_RECV_END) // already receive all data
000090  f0060010          AND      r0,r6,#0x10
000094  b100              CBZ      r0,|L9.152|
;;;974    			{
;;;975    				break;
000096  e003              B        |L9.160|
                  |L9.152|
;;;976    			}
;;;977                 		CodeStatus = I2Cx->I2STAT & I2C_STAT_CODE_BITMASK;
000098  6868              LDR      r0,[r5,#4]
00009a  f00009f8          AND      r9,r0,#0xf8
                  |L9.158|
00009e  e7c9              B        |L9.52|
                  |L9.160|
0000a0  bf00              NOP                            ;966
;;;978    		}
;;;979    		return SUCCESS;
0000a2  2001              MOVS     r0,#1
                  |L9.164|
;;;980    error:
;;;981    		return ERROR;
;;;982    	}
;;;983    
;;;984    	else if (Opt == I2C_TRANSFER_INTERRUPT)
;;;985    	{
;;;986    		// Setup tx_rx data, callback and interrupt handler
;;;987    		i2cdat[i2cId].txrx_setup = (uint32_t) TransferCfg;
;;;988    
;;;989    		// Set direction phase, write first
;;;990    		i2cdat[i2cId].dir = 0;
;;;991    
;;;992    		/* First Start condition -------------------------------------------------------------- */
;;;993    		// Reset STA, STO, SI
;;;994    		I2Cx->I2CONCLR = I2C_I2CONCLR_SIC|I2C_I2CONCLR_STOC|I2C_I2CONCLR_STAC;
;;;995    		I2Cx->I2CONSET = I2C_I2CONSET_STA;
;;;996    
;;;997    		I2C_IntCmd(I2Cx, TRUE);
;;;998    
;;;999    		return (SUCCESS);
;;;1000   	}
;;;1001   
;;;1002   	return ERROR;
;;;1003   }
0000a4  e8bd87f0          POP      {r4-r10,pc}
                  |L9.168|
0000a8  2000              MOVS     r0,#0                 ;981
0000aa  e7fb              B        |L9.164|
                  |L9.172|
0000ac  2f01              CMP      r7,#1                 ;984
0000ae  d111              BNE      |L9.212|
0000b0  4809              LDR      r0,|L9.216|
0000b2  f8404038          STR      r4,[r0,r8,LSL #3]     ;987
0000b6  2000              MOVS     r0,#0                 ;990
0000b8  4907              LDR      r1,|L9.216|
0000ba  eb0101c8          ADD      r1,r1,r8,LSL #3       ;990
0000be  6048              STR      r0,[r1,#4]            ;990
0000c0  2038              MOVS     r0,#0x38              ;994
0000c2  61a8              STR      r0,[r5,#0x18]         ;994
0000c4  2020              MOVS     r0,#0x20              ;995
0000c6  6028              STR      r0,[r5,#0]            ;995
0000c8  2101              MOVS     r1,#1                 ;997
0000ca  4628              MOV      r0,r5                 ;997
0000cc  f7fffffe          BL       I2C_IntCmd
0000d0  2001              MOVS     r0,#1                 ;999
0000d2  e7e7              B        |L9.164|
                  |L9.212|
0000d4  2000              MOVS     r0,#0                 ;1002
0000d6  e7e5              B        |L9.164|
;;;1004   
                          ENDP

                  |L9.216|
                          DCD      i2cdat

                          AREA ||i.I2C_MonitorGetDatabuffer||, CODE, READONLY, ALIGN=2

                  I2C_MonitorGetDatabuffer PROC
;;;1260    **********************************************************************/
;;;1261   uint8_t I2C_MonitorGetDatabuffer(LPC_I2C_TypeDef *I2Cx)
000000  b510              PUSH     {r4,lr}
;;;1262   {
000002  4604              MOV      r4,r0
;;;1263   	CHECK_PARAM(PARAM_I2Cx(I2Cx));
000004  4808              LDR      r0,|L10.40|
000006  4284              CMP      r4,r0
000008  d005              BEQ      |L10.22|
00000a  4808              LDR      r0,|L10.44|
00000c  4284              CMP      r4,r0
00000e  d002              BEQ      |L10.22|
000010  4807              LDR      r0,|L10.48|
000012  4284              CMP      r4,r0
000014  d100              BNE      |L10.24|
                  |L10.22|
000016  e004              B        |L10.34|
                  |L10.24|
000018  f24041ef          MOV      r1,#0x4ef
00001c  a005              ADR      r0,|L10.52|
00001e  f7fffffe          BL       check_failed
                  |L10.34|
;;;1264   	return ((uint8_t)(I2Cx->I2DATA_BUFFER));
000022  6ae0              LDR      r0,[r4,#0x2c]
000024  b2c0              UXTB     r0,r0
;;;1265   }
000026  bd10              POP      {r4,pc}
;;;1266   
                          ENDP

                  |L10.40|
                          DCD      0x4001c000
                  |L10.44|
                          DCD      0x4005c000
                  |L10.48|
                          DCD      0x400a0000
                  |L10.52|
000034  4c69625c          DCB      "Lib\\Drivers\\source\\lpc17xx_i2c.c",0
000038  44726976
00003c  6572735c
000040  736f7572
000044  63655c6c
000048  70633137
00004c  78785f69
000050  32632e63
000054  00      
000055  00                DCB      0
000056  00                DCB      0
000057  00                DCB      0

                          AREA ||i.I2C_MonitorHandler||, CODE, READONLY, ALIGN=2

                  I2C_MonitorHandler PROC
;;;1281    **********************************************************************/
;;;1282   BOOL_8 I2C_MonitorHandler(LPC_I2C_TypeDef *I2Cx, uint8_t *buffer, uint32_t size)
000000  b530              PUSH     {r4,r5,lr}
;;;1283   {
000002  4603              MOV      r3,r0
;;;1284   	BOOL_8 ret=FALSE;
000004  2000              MOVS     r0,#0
;;;1285   
;;;1286   	I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
000006  2408              MOVS     r4,#8
000008  619c              STR      r4,[r3,#0x18]
;;;1287   
;;;1288   	buffer[I2C_MonitorBufferIndex] = (uint8_t)(I2Cx->I2DATA_BUFFER);
00000a  6adc              LDR      r4,[r3,#0x2c]
00000c  4d06              LDR      r5,|L11.40|
00000e  682d              LDR      r5,[r5,#0]  ; I2C_MonitorBufferIndex
000010  554c              STRB     r4,[r1,r5]
;;;1289   	I2C_MonitorBufferIndex++;
000012  4c05              LDR      r4,|L11.40|
000014  6824              LDR      r4,[r4,#0]  ; I2C_MonitorBufferIndex
000016  1c64              ADDS     r4,r4,#1
000018  4d03              LDR      r5,|L11.40|
00001a  602c              STR      r4,[r5,#0]  ; I2C_MonitorBufferIndex
;;;1290   	if(I2C_MonitorBufferIndex >= size)
00001c  462c              MOV      r4,r5
00001e  6824              LDR      r4,[r4,#0]  ; I2C_MonitorBufferIndex
000020  4294              CMP      r4,r2
000022  d300              BCC      |L11.38|
;;;1291   	{
;;;1292   		ret = TRUE;
000024  2001              MOVS     r0,#1
                  |L11.38|
;;;1293   	}
;;;1294   	return ret;
;;;1295   }
000026  bd30              POP      {r4,r5,pc}
;;;1296   /*********************************************************************//**
                          ENDP

                  |L11.40|
                          DCD      I2C_MonitorBufferIndex

                          AREA ||i.I2C_MonitorModeCmd||, CODE, READONLY, ALIGN=2

                  I2C_MonitorModeCmd PROC
;;;1225    **********************************************************************/
;;;1226   void I2C_MonitorModeCmd(LPC_I2C_TypeDef *I2Cx, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1227   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1228   	CHECK_PARAM(PARAM_I2Cx(I2Cx));
000006  4816              LDR      r0,|L12.96|
000008  4284              CMP      r4,r0
00000a  d005              BEQ      |L12.24|
00000c  4815              LDR      r0,|L12.100|
00000e  4284              CMP      r4,r0
000010  d002              BEQ      |L12.24|
000012  4815              LDR      r0,|L12.104|
000014  4284              CMP      r4,r0
000016  d100              BNE      |L12.26|
                  |L12.24|
000018  e004              B        |L12.36|
                  |L12.26|
00001a  f24041cc          MOV      r1,#0x4cc
00001e  a013              ADR      r0,|L12.108|
000020  f7fffffe          BL       check_failed
                  |L12.36|
;;;1229   	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
000024  b10d              CBZ      r5,|L12.42|
000026  2d01              CMP      r5,#1
000028  d100              BNE      |L12.44|
                  |L12.42|
00002a  e004              B        |L12.54|
                  |L12.44|
00002c  f24041cd          MOV      r1,#0x4cd
000030  a00e              ADR      r0,|L12.108|
000032  f7fffffe          BL       check_failed
                  |L12.54|
;;;1230   
;;;1231   	if (NewState == ENABLE)
000036  2d01              CMP      r5,#1
000038  d108              BNE      |L12.76|
;;;1232   	{
;;;1233   		I2Cx->MMCTRL |= I2C_I2MMCTRL_MM_ENA;
00003a  69e0              LDR      r0,[r4,#0x1c]
00003c  f0400001          ORR      r0,r0,#1
000040  61e0              STR      r0,[r4,#0x1c]
;;;1234   		I2Cx->I2CONSET = I2C_I2CONSET_AA;
000042  2004              MOVS     r0,#4
000044  6020              STR      r0,[r4,#0]
;;;1235   		I2Cx->I2CONCLR = I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC;
000046  2028              MOVS     r0,#0x28
000048  61a0              STR      r0,[r4,#0x18]
00004a  e005              B        |L12.88|
                  |L12.76|
;;;1236   	}
;;;1237   	else
;;;1238   	{
;;;1239   		I2Cx->MMCTRL &= (~I2C_I2MMCTRL_MM_ENA) & I2C_I2MMCTRL_BITMASK;
00004c  69e0              LDR      r0,[r4,#0x1c]
00004e  f0000006          AND      r0,r0,#6
000052  61e0              STR      r0,[r4,#0x1c]
;;;1240   		I2Cx->I2CONCLR = I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC | I2C_I2CONCLR_AAC;
000054  202c              MOVS     r0,#0x2c
000056  61a0              STR      r0,[r4,#0x18]
                  |L12.88|
;;;1241   	}
;;;1242   	I2C_MonitorBufferIndex = 0;
000058  2000              MOVS     r0,#0
00005a  490d              LDR      r1,|L12.144|
00005c  6008              STR      r0,[r1,#0]  ; I2C_MonitorBufferIndex
;;;1243   }
00005e  bd70              POP      {r4-r6,pc}
;;;1244   
                          ENDP

                  |L12.96|
                          DCD      0x4001c000
                  |L12.100|
                          DCD      0x4005c000
                  |L12.104|
                          DCD      0x400a0000
                  |L12.108|
00006c  4c69625c          DCB      "Lib\\Drivers\\source\\lpc17xx_i2c.c",0
000070  44726976
000074  6572735c
000078  736f7572
00007c  63655c6c
000080  70633137
000084  78785f69
000088  32632e63
00008c  00      
00008d  00                DCB      0
00008e  00                DCB      0
00008f  00                DCB      0
                  |L12.144|
                          DCD      I2C_MonitorBufferIndex

                          AREA ||i.I2C_MonitorModeConfig||, CODE, READONLY, ALIGN=2

                  I2C_MonitorModeConfig PROC
;;;1197    **********************************************************************/
;;;1198   void I2C_MonitorModeConfig(LPC_I2C_TypeDef *I2Cx, uint32_t MonitorCfgType, FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1199   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1200   	CHECK_PARAM(PARAM_I2Cx(I2Cx));
000008  4813              LDR      r0,|L13.88|
00000a  4284              CMP      r4,r0
00000c  d005              BEQ      |L13.26|
00000e  4813              LDR      r0,|L13.92|
000010  4284              CMP      r4,r0
000012  d002              BEQ      |L13.26|
000014  4812              LDR      r0,|L13.96|
000016  4284              CMP      r4,r0
000018  d100              BNE      |L13.28|
                  |L13.26|
00001a  e004              B        |L13.38|
                  |L13.28|
00001c  f44f6196          MOV      r1,#0x4b0
000020  a010              ADR      r0,|L13.100|
000022  f7fffffe          BL       check_failed
                  |L13.38|
;;;1201   	CHECK_PARAM(PARAM_I2C_MONITOR_CFG(MonitorCfgType));
000026  2d02              CMP      r5,#2
000028  d000              BEQ      |L13.44|
00002a  bf00              NOP      
                  |L13.44|
00002c  bf00              NOP      
;;;1202   	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
00002e  b10e              CBZ      r6,|L13.52|
000030  2e01              CMP      r6,#1
000032  d100              BNE      |L13.54|
                  |L13.52|
000034  e004              B        |L13.64|
                  |L13.54|
000036  f24041b2          MOV      r1,#0x4b2
00003a  a00a              ADR      r0,|L13.100|
00003c  f7fffffe          BL       check_failed
                  |L13.64|
;;;1203   
;;;1204   	if (NewState == ENABLE)
000040  2e01              CMP      r6,#1
000042  d103              BNE      |L13.76|
;;;1205   	{
;;;1206   		I2Cx->MMCTRL |= MonitorCfgType;
000044  69e0              LDR      r0,[r4,#0x1c]
000046  4328              ORRS     r0,r0,r5
000048  61e0              STR      r0,[r4,#0x1c]
00004a  e004              B        |L13.86|
                  |L13.76|
;;;1207   	}
;;;1208   	else
;;;1209   	{
;;;1210   		I2Cx->MMCTRL &= (~MonitorCfgType) & I2C_I2MMCTRL_BITMASK;
00004c  69e0              LDR      r0,[r4,#0x1c]
00004e  2107              MOVS     r1,#7
000050  43a9              BICS     r1,r1,r5
000052  4008              ANDS     r0,r0,r1
000054  61e0              STR      r0,[r4,#0x1c]
                  |L13.86|
;;;1211   	}
;;;1212   }
000056  bd70              POP      {r4-r6,pc}
;;;1213   
                          ENDP

                  |L13.88|
                          DCD      0x4001c000
                  |L13.92|
                          DCD      0x4005c000
                  |L13.96|
                          DCD      0x400a0000
                  |L13.100|
000064  4c69625c          DCB      "Lib\\Drivers\\source\\lpc17xx_i2c.c",0
000068  44726976
00006c  6572735c
000070  736f7572
000074  63655c6c
000078  70633137
00007c  78785f69
000080  32632e63
000084  00      
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0

                          AREA ||i.I2C_SendByte||, CODE, READONLY, ALIGN=1

                  I2C_SendByte PROC
;;;179     *********************************************************************/
;;;180    static uint32_t I2C_SendByte (LPC_I2C_TypeDef *I2Cx, uint8_t databyte)
000000  4602              MOV      r2,r0
;;;181    {
000002  460b              MOV      r3,r1
;;;182    	uint32_t CodeStatus = I2Cx->I2STAT & I2C_STAT_CODE_BITMASK;
000004  6850              LDR      r0,[r2,#4]
000006  f00001f8          AND      r1,r0,#0xf8
;;;183    
;;;184    	if((CodeStatus != I2C_I2STAT_M_TX_START) &&
00000a  2908              CMP      r1,#8
00000c  d007              BEQ      |L14.30|
;;;185    		(CodeStatus != I2C_I2STAT_M_TX_RESTART) &&
00000e  2910              CMP      r1,#0x10
000010  d005              BEQ      |L14.30|
;;;186    		(CodeStatus != I2C_I2STAT_M_TX_SLAW_ACK)  &&
000012  2918              CMP      r1,#0x18
000014  d003              BEQ      |L14.30|
;;;187    		(CodeStatus != I2C_I2STAT_M_TX_DAT_ACK)  )
000016  2928              CMP      r1,#0x28
000018  d001              BEQ      |L14.30|
;;;188    	{
;;;189    		return CodeStatus;
00001a  4608              MOV      r0,r1
                  |L14.28|
;;;190    	}
;;;191    	
;;;192    	/* Make sure start bit is not active */
;;;193    	if (I2Cx->I2CONSET & I2C_I2CONSET_STA)
;;;194    	{
;;;195    		I2Cx->I2CONCLR = I2C_I2CONCLR_STAC;
;;;196    	}
;;;197    	I2Cx->I2DAT = databyte & I2C_I2DAT_BITMASK;
;;;198    
;;;199    	I2Cx->I2CONSET = I2C_I2CONSET_AA;
;;;200    
;;;201    	I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
;;;202    
;;;203    	return (I2Cx->I2STAT & I2C_STAT_CODE_BITMASK);
;;;204    }
00001c  4770              BX       lr
                  |L14.30|
00001e  6810              LDR      r0,[r2,#0]            ;193
000020  f0000020          AND      r0,r0,#0x20           ;193
000024  b108              CBZ      r0,|L14.42|
000026  2020              MOVS     r0,#0x20              ;195
000028  6190              STR      r0,[r2,#0x18]         ;195
                  |L14.42|
00002a  b2d8              UXTB     r0,r3                 ;197
00002c  6090              STR      r0,[r2,#8]            ;197
00002e  2004              MOVS     r0,#4                 ;199
000030  6010              STR      r0,[r2,#0]            ;199
000032  2008              MOVS     r0,#8                 ;201
000034  6190              STR      r0,[r2,#0x18]         ;201
000036  6850              LDR      r0,[r2,#4]            ;203
000038  f00000f8          AND      r0,r0,#0xf8           ;203
00003c  e7ee              B        |L14.28|
;;;205    
                          ENDP


                          AREA ||i.I2C_SetClock||, CODE, READONLY, ALIGN=2

                  I2C_SetClock PROC
;;;242     ***********************************************************************/
;;;243    static void I2C_SetClock (LPC_I2C_TypeDef *I2Cx, uint32_t target_clock)
000000  b570              PUSH     {r4-r6,lr}
;;;244    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;245    	uint32_t temp;
;;;246    
;;;247    	CHECK_PARAM(PARAM_I2Cx(I2Cx));
000006  4817              LDR      r0,|L15.100|
000008  4284              CMP      r4,r0
00000a  d005              BEQ      |L15.24|
00000c  4816              LDR      r0,|L15.104|
00000e  4284              CMP      r4,r0
000010  d002              BEQ      |L15.24|
000012  4816              LDR      r0,|L15.108|
000014  4284              CMP      r4,r0
000016  d100              BNE      |L15.26|
                  |L15.24|
000018  e003              B        |L15.34|
                  |L15.26|
00001a  21f7              MOVS     r1,#0xf7
00001c  a014              ADR      r0,|L15.112|
00001e  f7fffffe          BL       check_failed
                  |L15.34|
;;;248    
;;;249    	// Get PCLK of I2C controller
;;;250    	if (I2Cx == LPC_I2C0)
000022  4810              LDR      r0,|L15.100|
000024  4284              CMP      r4,r0
000026  d105              BNE      |L15.52|
;;;251    	{
;;;252    		temp = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_I2C0) / target_clock;
000028  200e              MOVS     r0,#0xe
00002a  f7fffffe          BL       CLKPWR_GetPCLK
00002e  fbb0f5f6          UDIV     r5,r0,r6
000032  e010              B        |L15.86|
                  |L15.52|
;;;253    	}
;;;254    	else if (I2Cx == LPC_I2C1)
000034  480c              LDR      r0,|L15.104|
000036  4284              CMP      r4,r0
000038  d105              BNE      |L15.70|
;;;255    	{
;;;256    		temp = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_I2C1) / target_clock;
00003a  2026              MOVS     r0,#0x26
00003c  f7fffffe          BL       CLKPWR_GetPCLK
000040  fbb0f5f6          UDIV     r5,r0,r6
000044  e007              B        |L15.86|
                  |L15.70|
;;;257    	}
;;;258    	else if (I2Cx == LPC_I2C2)
000046  4809              LDR      r0,|L15.108|
000048  4284              CMP      r4,r0
00004a  d104              BNE      |L15.86|
;;;259    	{
;;;260    		temp = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_I2C2) / target_clock;
00004c  2034              MOVS     r0,#0x34
00004e  f7fffffe          BL       CLKPWR_GetPCLK
000052  fbb0f5f6          UDIV     r5,r0,r6
                  |L15.86|
;;;261    	}
;;;262    
;;;263    	/* Set the I2C clock value to register */
;;;264    	I2Cx->I2SCLH = (uint32_t)(temp / 2);
000056  0868              LSRS     r0,r5,#1
000058  6120              STR      r0,[r4,#0x10]
;;;265    	I2Cx->I2SCLL = (uint32_t)(temp - I2Cx->I2SCLH);
00005a  6920              LDR      r0,[r4,#0x10]
00005c  1a28              SUBS     r0,r5,r0
00005e  6160              STR      r0,[r4,#0x14]
;;;266    }
000060  bd70              POP      {r4-r6,pc}
;;;267    /* End of Private Functions --------------------------------------------------- */
                          ENDP

000062  0000              DCW      0x0000
                  |L15.100|
                          DCD      0x4001c000
                  |L15.104|
                          DCD      0x4005c000
                  |L15.108|
                          DCD      0x400a0000
                  |L15.112|
000070  4c69625c          DCB      "Lib\\Drivers\\source\\lpc17xx_i2c.c",0
000074  44726976
000078  6572735c
00007c  736f7572
000080  63655c6c
000084  70633137
000088  78785f69
00008c  32632e63
000090  00      
000091  00                DCB      0
000092  00                DCB      0
000093  00                DCB      0

                          AREA ||i.I2C_SetOwnSlaveAddr||, CODE, READONLY, ALIGN=2

                  I2C_SetOwnSlaveAddr PROC
;;;1144    **********************************************************************/
;;;1145   void I2C_SetOwnSlaveAddr(LPC_I2C_TypeDef *I2Cx, I2C_OWNSLAVEADDR_CFG_Type *OwnSlaveAddrConfigStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;1146   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1147   	uint32_t tmp;
;;;1148   	CHECK_PARAM(PARAM_I2Cx(I2Cx));
000006  4827              LDR      r0,|L16.164|
000008  4284              CMP      r4,r0
00000a  d005              BEQ      |L16.24|
00000c  4826              LDR      r0,|L16.168|
00000e  4284              CMP      r4,r0
000010  d002              BEQ      |L16.24|
000012  4826              LDR      r0,|L16.172|
000014  4284              CMP      r4,r0
000016  d100              BNE      |L16.26|
                  |L16.24|
000018  e004              B        |L16.36|
                  |L16.26|
00001a  f240417c          MOV      r1,#0x47c
00001e  a024              ADR      r0,|L16.176|
000020  f7fffffe          BL       check_failed
                  |L16.36|
;;;1149   	CHECK_PARAM(PARAM_I2C_SLAVEADDR_CH(OwnSlaveAddrConfigStruct->SlaveAddrChannel));
000024  7828              LDRB     r0,[r5,#0]
000026  2803              CMP      r0,#3
000028  dc00              BGT      |L16.44|
00002a  e004              B        |L16.54|
                  |L16.44|
00002c  f240417d          MOV      r1,#0x47d
000030  a01f              ADR      r0,|L16.176|
000032  f7fffffe          BL       check_failed
                  |L16.54|
;;;1150   	CHECK_PARAM(PARAM_FUNCTIONALSTATE(OwnSlaveAddrConfigStruct->GeneralCallState));
000036  78a8              LDRB     r0,[r5,#2]
000038  b110              CBZ      r0,|L16.64|
00003a  78a8              LDRB     r0,[r5,#2]
00003c  2801              CMP      r0,#1
00003e  d100              BNE      |L16.66|
                  |L16.64|
000040  e004              B        |L16.76|
                  |L16.66|
000042  f240417e          MOV      r1,#0x47e
000046  a01a              ADR      r0,|L16.176|
000048  f7fffffe          BL       check_failed
                  |L16.76|
;;;1151   
;;;1152   	tmp = (((uint32_t)(OwnSlaveAddrConfigStruct->SlaveAddr_7bit << 1)) \
00004c  78a8              LDRB     r0,[r5,#2]
00004e  2801              CMP      r0,#1
000050  d100              BNE      |L16.84|
;;;1153   			| ((OwnSlaveAddrConfigStruct->GeneralCallState == ENABLE) ? 0x01 : 0x00))& I2C_I2ADR_BITMASK;
000052  e000              B        |L16.86|
                  |L16.84|
000054  2000              MOVS     r0,#0
                  |L16.86|
000056  7869              LDRB     r1,[r5,#1]
000058  ea400041          ORR      r0,r0,r1,LSL #1
00005c  b2c6              UXTB     r6,r0
;;;1154   	switch (OwnSlaveAddrConfigStruct->SlaveAddrChannel)
00005e  7828              LDRB     r0,[r5,#0]
000060  b130              CBZ      r0,|L16.112|
000062  2801              CMP      r0,#1
000064  d00a              BEQ      |L16.124|
000066  2802              CMP      r0,#2
000068  d00e              BEQ      |L16.136|
00006a  2803              CMP      r0,#3
00006c  d118              BNE      |L16.160|
00006e  e011              B        |L16.148|
                  |L16.112|
;;;1155   	{
;;;1156   	case 0:
;;;1157   		I2Cx->I2ADR0 = tmp;
000070  60e6              STR      r6,[r4,#0xc]
;;;1158   		I2Cx->I2MASK0 = I2C_I2MASK_MASK((uint32_t) \
000072  78e8              LDRB     r0,[r5,#3]
000074  f00000fe          AND      r0,r0,#0xfe
000078  6320              STR      r0,[r4,#0x30]
;;;1159   				(OwnSlaveAddrConfigStruct->SlaveAddrMaskValue));
;;;1160   		break;
00007a  e011              B        |L16.160|
                  |L16.124|
;;;1161   	case 1:
;;;1162   		I2Cx->I2ADR1 = tmp;
00007c  6226              STR      r6,[r4,#0x20]
;;;1163   		I2Cx->I2MASK1 = I2C_I2MASK_MASK((uint32_t) \
00007e  78e8              LDRB     r0,[r5,#3]
000080  f00000fe          AND      r0,r0,#0xfe
000084  6360              STR      r0,[r4,#0x34]
;;;1164   				(OwnSlaveAddrConfigStruct->SlaveAddrMaskValue));
;;;1165   		break;
000086  e00b              B        |L16.160|
                  |L16.136|
;;;1166   	case 2:
;;;1167   		I2Cx->I2ADR2 = tmp;
000088  6266              STR      r6,[r4,#0x24]
;;;1168   		I2Cx->I2MASK2 = I2C_I2MASK_MASK((uint32_t) \
00008a  78e8              LDRB     r0,[r5,#3]
00008c  f00000fe          AND      r0,r0,#0xfe
000090  63a0              STR      r0,[r4,#0x38]
;;;1169   				(OwnSlaveAddrConfigStruct->SlaveAddrMaskValue));
;;;1170   		break;
000092  e005              B        |L16.160|
                  |L16.148|
;;;1171   	case 3:
;;;1172   		I2Cx->I2ADR3 = tmp;
000094  62a6              STR      r6,[r4,#0x28]
;;;1173   		I2Cx->I2MASK3 = I2C_I2MASK_MASK((uint32_t) \
000096  78e8              LDRB     r0,[r5,#3]
000098  f00000fe          AND      r0,r0,#0xfe
00009c  63e0              STR      r0,[r4,#0x3c]
;;;1174   				(OwnSlaveAddrConfigStruct->SlaveAddrMaskValue));
;;;1175   		break;
00009e  bf00              NOP      
                  |L16.160|
0000a0  bf00              NOP                            ;1160
;;;1176   	}
;;;1177   }
0000a2  bd70              POP      {r4-r6,pc}
;;;1178   
                          ENDP

                  |L16.164|
                          DCD      0x4001c000
                  |L16.168|
                          DCD      0x4005c000
                  |L16.172|
                          DCD      0x400a0000
                  |L16.176|
0000b0  4c69625c          DCB      "Lib\\Drivers\\source\\lpc17xx_i2c.c",0
0000b4  44726976
0000b8  6572735c
0000bc  736f7572
0000c0  63655c6c
0000c4  70633137
0000c8  78785f69
0000cc  32632e63
0000d0  00      
0000d1  00                DCB      0
0000d2  00                DCB      0
0000d3  00                DCB      0

                          AREA ||i.I2C_SlaveHandler||, CODE, READONLY, ALIGN=2

                  I2C_SlaveHandler PROC
;;;829     **********************************************************************/
;;;830    void I2C_SlaveHandler (LPC_I2C_TypeDef  *I2Cx)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;831    {
000004  4604              MOV      r4,r0
;;;832    	uint32_t i2cId = I2C_getNum(I2Cx);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       I2C_getNum
00000c  4680              MOV      r8,r0
;;;833    	uint8_t returnCode;
;;;834    	I2C_S_SETUP_Type *txrx_setup;
;;;835    	uint32_t timeout;
;;;836    	int32_t Ret = I2C_OK;
00000e  2700              MOVS     r7,#0
;;;837    
;;;838    	txrx_setup = (I2C_S_SETUP_Type *) i2cdat[i2cId].txrx_setup;
000010  4820              LDR      r0,|L17.148|
000012  f8505038          LDR      r5,[r0,r8,LSL #3]
;;;839    
;;;840    handle_state:
000016  bf00              NOP      
                  |L17.24|
;;;841    
;;;842    	returnCode = (I2Cx->I2STAT & I2C_STAT_CODE_BITMASK);
000018  6860              LDR      r0,[r4,#4]
00001a  f00006f8          AND      r6,r0,#0xf8
;;;843    	// Save current status
;;;844    	txrx_setup->status = returnCode;
00001e  61ae              STR      r6,[r5,#0x18]
;;;845    
;;;846    
;;;847    	Ret = I2C_SlaveHanleStates(I2Cx, returnCode, txrx_setup);
000020  462a              MOV      r2,r5
000022  4631              MOV      r1,r6
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       I2C_SlaveHanleStates
00002a  4607              MOV      r7,r0
;;;848    
;;;849    	if(I2C_CheckError(Ret))
00002c  f0075080          AND      r0,r7,#0x10000000
000030  b100              CBZ      r0,|L17.52|
;;;850    	{
;;;851    		goto s_int_end;
000032  e023              B        |L17.124|
                  |L17.52|
;;;852    	}
;;;853    	else if (Ret & I2C_STA_STO_RECV)
000034  f0070020          AND      r0,r7,#0x20
000038  b1d0              CBZ      r0,|L17.112|
;;;854    	{
;;;855    		// Temporally lock the interrupt for timeout condition
;;;856    		I2C_IntCmd(I2Cx, FALSE);
00003a  2100              MOVS     r1,#0
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       I2C_IntCmd
;;;857    		// enable time out
;;;858    		timeout = I2C_SLAVE_TIME_OUT;
000042  f44f3980          MOV      r9,#0x10000
;;;859    		while(1)
000046  e012              B        |L17.110|
                  |L17.72|
;;;860    		{
;;;861    			if (I2Cx->I2CONSET & I2C_I2CONSET_SI)
000048  6820              LDR      r0,[r4,#0]
00004a  f0000008          AND      r0,r0,#8
00004e  b120              CBZ      r0,|L17.90|
;;;862    			{
;;;863    				// re-Enable interrupt
;;;864    				I2C_IntCmd(I2Cx, TRUE);
000050  2101              MOVS     r1,#1
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       I2C_IntCmd
;;;865    				goto handle_state;
000058  e7de              B        |L17.24|
                  |L17.90|
;;;866    			}
;;;867    			else
;;;868    			{
;;;869    				timeout--;
00005a  f1a90901          SUB      r9,r9,#1
;;;870    				if (timeout == 0)
00005e  f1b90f00          CMP      r9,#0
000062  d104              BNE      |L17.110|
;;;871    				{
;;;872    					// timeout occur, it's really a stop condition
;;;873    					txrx_setup->status |= I2C_SETUP_STATUS_DONE;
000064  69a8              LDR      r0,[r5,#0x18]
000066  f4406080          ORR      r0,r0,#0x400
00006a  61a8              STR      r0,[r5,#0x18]
;;;874    					goto s_int_end;
00006c  e006              B        |L17.124|
                  |L17.110|
00006e  e7eb              B        |L17.72|
                  |L17.112|
;;;875    				}
;;;876    			}
;;;877    		}	
;;;878    	}
;;;879    	else if(Ret &I2C_SEND_END)
000070  f0070008          AND      r0,r7,#8
000074  b100              CBZ      r0,|L17.120|
;;;880    	{
;;;881    		goto s_int_end;
000076  e001              B        |L17.124|
                  |L17.120|
;;;882    	}
;;;883    	else
;;;884    	{
;;;885    		return;
;;;886    	}
;;;887    
;;;888    s_int_end:
;;;889    	// Disable interrupt
;;;890    	I2C_IntCmd(I2Cx, FALSE);
;;;891    	I2Cx->I2CONCLR = I2C_I2CONCLR_AAC | I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC;
;;;892    
;;;893    	I2C_SlaveComplete[i2cId] = TRUE;
;;;894    }
000078  e8bd87f0          POP      {r4-r10,pc}
                  |L17.124|
00007c  2100              MOVS     r1,#0                 ;890
00007e  4620              MOV      r0,r4                 ;890
000080  f7fffffe          BL       I2C_IntCmd
000084  202c              MOVS     r0,#0x2c              ;891
000086  61a0              STR      r0,[r4,#0x18]         ;891
000088  2001              MOVS     r0,#1                 ;893
00008a  4903              LDR      r1,|L17.152|
00008c  f8410028          STR      r0,[r1,r8,LSL #2]     ;893
000090  bf00              NOP      
000092  e7f1              B        |L17.120|
;;;895    
                          ENDP

                  |L17.148|
                          DCD      i2cdat
                  |L17.152|
                          DCD      I2C_SlaveComplete

                          AREA ||i.I2C_SlaveHanleStates||, CODE, READONLY, ALIGN=1

                  I2C_SlaveHanleStates PROC
;;;584     **********************************************************************/
;;;585    int32_t I2C_SlaveHanleStates(LPC_I2C_TypeDef  *I2Cx, uint32_t CodeStatus, I2C_S_SETUP_Type *TransferCfg)
000000  b5f0              PUSH     {r4-r7,lr}
;;;586    {
000002  4603              MOV      r3,r0
000004  460d              MOV      r5,r1
;;;587    
;;;588    	int32_t Ret = I2C_OK;
000006  2000              MOVS     r0,#0
;;;589    	uint8_t *txdat;
;;;590    	uint8_t *rxdat;
;;;591    
;;;592    	//get buffer to send/receive
;;;593    	txdat = (uint8_t *) &TransferCfg->tx_data[TransferCfg->tx_count];
000008  6897              LDR      r7,[r2,#8]
00000a  6816              LDR      r6,[r2,#0]
00000c  19f1              ADDS     r1,r6,r7
;;;594    	rxdat = (uint8_t *) &TransferCfg->rx_data[TransferCfg->rx_count];
00000e  6957              LDR      r7,[r2,#0x14]
000010  68d6              LDR      r6,[r2,#0xc]
000012  19f4              ADDS     r4,r6,r7
;;;595    	
;;;596    	switch (CodeStatus)
000014  f0050607          AND      r6,r5,#7
000018  2e00              CMP      r6,#0
00001a  d17f              BNE      |L18.284|
00001c  10ee              ASRS     r6,r5,#3
00001e  3e0c              SUBS     r6,r6,#0xc
000020  2e14              CMP      r6,#0x14
000022  d27b              BCS      |L18.284|
000024  e8dff006          TBB      [pc,r6]
000028  0a150b10          DCB      0x0a,0x15,0x0b,0x10
00002c  166d306e          DCB      0x16,0x6d,0x30,0x6e
000030  74405341          DCB      0x74,0x40,0x53,0x41
000034  66657a7a          DCB      0x66,0x65,0x7a,0x7a
000038  7a7a7a7b          DCB      0x7a,0x7a,0x7a,0x7b
;;;597    	{
;;;598    		/* Reading phase -------------------------------------------------------- */
;;;599    		/* Own SLA+R has been received, ACK has been returned */
;;;600    		case I2C_I2STAT_S_RX_SLAW_ACK:
;;;601    
;;;602    		/* General call address has been received, ACK has been returned */
;;;603    		case I2C_I2STAT_S_RX_GENCALL_ACK:
00003c  bf00              NOP      
;;;604    			I2Cx->I2CONSET = I2C_I2CONSET_AA;
00003e  2604              MOVS     r6,#4
000040  601e              STR      r6,[r3,#0]
;;;605    			I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
000042  2608              MOVS     r6,#8
000044  619e              STR      r6,[r3,#0x18]
;;;606    			break;
000046  e06f              B        |L18.296|
;;;607    		/* Arbitration has been lost in Slave Address + R/W bit as bus Master. General Call has
;;;608    			been received and ACK has been returned.*/
;;;609    		case I2C_I2STAT_S_RX_ARB_LOST_M_GENCALL:
;;;610    			I2Cx->I2CONSET = I2C_I2CONSET_AA|I2C_I2CONSET_STA;
000048  2624              MOVS     r6,#0x24
00004a  601e              STR      r6,[r3,#0]
;;;611    			I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
00004c  2608              MOVS     r6,#8
00004e  619e              STR      r6,[r3,#0x18]
;;;612    			break;
000050  e06a              B        |L18.296|
;;;613    		/* Previously addressed with own SLA;
;;;614    		 * DATA byte has been received;
;;;615    		 * ACK has been returned */
;;;616    		case I2C_I2STAT_S_RX_ARB_LOST_M_SLA:
;;;617    		case I2C_I2STAT_S_RX_PRE_SLA_DAT_ACK:
000052  bf00              NOP      
;;;618    
;;;619    			/*
;;;620    			 * All data bytes that over-flow the specified receive
;;;621    			 * data length, just ignore them.
;;;622    			 */
;;;623    			if ((TransferCfg->rx_count < TransferCfg->rx_length) && (TransferCfg->rx_data != NULL))
000054  6956              LDR      r6,[r2,#0x14]
000056  6917              LDR      r7,[r2,#0x10]
000058  42be              CMP      r6,r7
00005a  d208              BCS      |L18.110|
00005c  68d6              LDR      r6,[r2,#0xc]
00005e  b136              CBZ      r6,|L18.110|
;;;624    			{
;;;625    				*rxdat++ = (uint8_t)I2Cx->I2DAT;
000060  689e              LDR      r6,[r3,#8]
000062  f8046b01          STRB     r6,[r4],#1
;;;626    
;;;627    				TransferCfg->rx_count++;
000066  6956              LDR      r6,[r2,#0x14]
000068  1c76              ADDS     r6,r6,#1
00006a  6156              STR      r6,[r2,#0x14]
;;;628    
;;;629    				Ret = I2C_BYTE_RECV;
00006c  2002              MOVS     r0,#2
                  |L18.110|
;;;630    			}
;;;631    			if(TransferCfg->rx_count == (TransferCfg->rx_length) ) {
00006e  6956              LDR      r6,[r2,#0x14]
000070  6917              LDR      r7,[r2,#0x10]
000072  42be              CMP      r6,r7
000074  d103              BNE      |L18.126|
;;;632    				I2Cx->I2CONCLR = I2C_I2CONCLR_AAC|I2C_I2CONCLR_SIC;
000076  260c              MOVS     r6,#0xc
000078  619e              STR      r6,[r3,#0x18]
;;;633    				Ret = I2C_BYTE_RECV;
00007a  2002              MOVS     r0,#2
00007c  e003              B        |L18.134|
                  |L18.126|
;;;634    			}
;;;635    			else {
;;;636    				I2Cx->I2CONSET = I2C_I2CONSET_AA;
00007e  2604              MOVS     r6,#4
000080  601e              STR      r6,[r3,#0]
;;;637    				I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
000082  2608              MOVS     r6,#8
000084  619e              STR      r6,[r3,#0x18]
                  |L18.134|
;;;638    			}
;;;639    			
;;;640    			break;
000086  e04f              B        |L18.296|
;;;641    		/* DATA has been received, Only the first data byte will be received with ACK. Additional
;;;642    				data will be received with NOT ACK. */
;;;643    		case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_ACK:
;;;644    			if ((TransferCfg->rx_count < TransferCfg->rx_length) && (TransferCfg->rx_data != NULL))
000088  6956              LDR      r6,[r2,#0x14]
00008a  6917              LDR      r7,[r2,#0x10]
00008c  42be              CMP      r6,r7
00008e  d208              BCS      |L18.162|
000090  68d6              LDR      r6,[r2,#0xc]
000092  b136              CBZ      r6,|L18.162|
;;;645    			{
;;;646    				*rxdat++ = (uint8_t)I2Cx->I2DAT;
000094  689e              LDR      r6,[r3,#8]
000096  f8046b01          STRB     r6,[r4],#1
;;;647    
;;;648    				TransferCfg->rx_count++;
00009a  6956              LDR      r6,[r2,#0x14]
00009c  1c76              ADDS     r6,r6,#1
00009e  6156              STR      r6,[r2,#0x14]
;;;649    
;;;650    				Ret = I2C_BYTE_RECV;
0000a0  2002              MOVS     r0,#2
                  |L18.162|
;;;651    			}
;;;652    			I2Cx->I2CONCLR = I2C_I2CONCLR_AAC|I2C_I2CONCLR_SIC;
0000a2  260c              MOVS     r6,#0xc
0000a4  619e              STR      r6,[r3,#0x18]
;;;653    			break;
0000a6  e03f              B        |L18.296|
;;;654    
;;;655    		/* Writing phase -------------------------------------------------------- */
;;;656    		/* Own SLA+R has been received, ACK has been returned */
;;;657    		case I2C_I2STAT_S_TX_SLAR_ACK:
;;;658    
;;;659    		/* Data has been transmitted, ACK has been received */
;;;660    		case I2C_I2STAT_S_TX_DAT_ACK:
0000a8  bf00              NOP      
;;;661    			/*
;;;662    			 * All data bytes that over-flow the specified receive
;;;663    			 * data length, just ignore them.
;;;664    			 */
;;;665    			if ((TransferCfg->tx_count < TransferCfg->tx_length) && (TransferCfg->tx_data != NULL))
0000aa  6896              LDR      r6,[r2,#8]
0000ac  6857              LDR      r7,[r2,#4]
0000ae  42be              CMP      r6,r7
0000b0  d208              BCS      |L18.196|
0000b2  6816              LDR      r6,[r2,#0]
0000b4  b136              CBZ      r6,|L18.196|
;;;666    			{
;;;667    				I2Cx->I2DAT = *txdat++;
0000b6  f8116b01          LDRB     r6,[r1],#1
0000ba  609e              STR      r6,[r3,#8]
;;;668    
;;;669    				TransferCfg->tx_count++;
0000bc  6896              LDR      r6,[r2,#8]
0000be  1c76              ADDS     r6,r6,#1
0000c0  6096              STR      r6,[r2,#8]
;;;670    
;;;671    				Ret = I2C_BYTE_SENT;
0000c2  2001              MOVS     r0,#1
                  |L18.196|
;;;672    			}
;;;673    
;;;674    			I2Cx->I2CONSET = I2C_I2CONSET_AA;
0000c4  2604              MOVS     r6,#4
0000c6  601e              STR      r6,[r3,#0]
;;;675    			I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
0000c8  2608              MOVS     r6,#8
0000ca  619e              STR      r6,[r3,#0x18]
;;;676    			break;
0000cc  e02c              B        |L18.296|
;;;677    		/* Arbitration lost in Slave Address and R/W bit as bus Master. Own Slave Address + Read
;;;678    				has been received, ACK has been returned. */
;;;679    		case I2C_I2STAT_S_TX_ARB_LOST_M_SLA:
;;;680    			if ((TransferCfg->tx_count < TransferCfg->tx_length) && (TransferCfg->tx_data != NULL))
0000ce  6896              LDR      r6,[r2,#8]
0000d0  6857              LDR      r7,[r2,#4]
0000d2  42be              CMP      r6,r7
0000d4  d208              BCS      |L18.232|
0000d6  6816              LDR      r6,[r2,#0]
0000d8  b136              CBZ      r6,|L18.232|
;;;681    			{
;;;682    				I2Cx->I2DAT = *txdat++;
0000da  f8116b01          LDRB     r6,[r1],#1
0000de  609e              STR      r6,[r3,#8]
;;;683    
;;;684    				TransferCfg->tx_count++;
0000e0  6896              LDR      r6,[r2,#8]
0000e2  1c76              ADDS     r6,r6,#1
0000e4  6096              STR      r6,[r2,#8]
;;;685    
;;;686    				Ret = I2C_BYTE_SENT;
0000e6  2001              MOVS     r0,#1
                  |L18.232|
;;;687    			}
;;;688    			I2Cx->I2CONSET = I2C_I2CONSET_AA|I2C_I2CONSET_STA;
0000e8  2624              MOVS     r6,#0x24
0000ea  601e              STR      r6,[r3,#0]
;;;689    			I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
0000ec  2608              MOVS     r6,#8
0000ee  619e              STR      r6,[r3,#0x18]
;;;690    			break;
0000f0  e01a              B        |L18.296|
;;;691    			
;;;692    		case I2C_I2STAT_S_TX_LAST_DAT_ACK:
;;;693    		/* Data has been transmitted, NACK has been received,
;;;694    		 * that means there's no more data to send, exit now */
;;;695    		/*
;;;696    		 * Note: Don't wait for stop event since in slave transmit mode,
;;;697    		 * since there no proof lets us know when a stop signal has been received
;;;698    		 * on slave side.
;;;699    		 */
;;;700    		case I2C_I2STAT_S_TX_DAT_NACK:
0000f2  bf00              NOP      
;;;701    			I2Cx->I2CONSET = I2C_I2CONSET_AA;
0000f4  2604              MOVS     r6,#4
0000f6  601e              STR      r6,[r3,#0]
;;;702    			I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
0000f8  2608              MOVS     r6,#8
0000fa  619e              STR      r6,[r3,#0x18]
;;;703    			Ret = I2C_SEND_END;
0000fc  2008              MOVS     r0,#8
;;;704    			break;
0000fe  e013              B        |L18.296|
000100  e00c              B        |L18.284|
;;;705    
;;;706    		/* Previously addressed with own SLA;
;;;707    		 * DATA byte has been received;
;;;708    		 * NOT ACK has been returned */
;;;709    		case I2C_I2STAT_S_RX_PRE_SLA_DAT_NACK:
;;;710    
;;;711    		/* DATA has been received, NOT ACK has been returned */
;;;712    		case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_NACK:
000102  bf00              NOP      
;;;713    			I2Cx->I2CONSET = I2C_I2CONSET_AA;
000104  2604              MOVS     r6,#4
000106  601e              STR      r6,[r3,#0]
;;;714    			I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
000108  2608              MOVS     r6,#8
00010a  619e              STR      r6,[r3,#0x18]
;;;715    			Ret = I2C_RECV_END;
00010c  2010              MOVS     r0,#0x10
;;;716    			break;
00010e  e00b              B        |L18.296|
;;;717    
;;;718    		/*
;;;719    		 * Note that: Return code only let us know a stop condition mixed
;;;720    		 * with a repeat start condition in the same code value.
;;;721    		 * So we should provide a time-out. In case this is really a stop
;;;722    		 * condition, this will return back after time out condition. Otherwise,
;;;723    		 * next session that is slave receive data will be completed.
;;;724    		 */
;;;725    
;;;726    		/* A Stop or a repeat start condition */
;;;727    		case I2C_I2STAT_S_RX_STA_STO_SLVREC_SLVTRX:
;;;728    			I2Cx->I2CONSET = I2C_I2CONSET_AA;
000110  2604              MOVS     r6,#4
000112  601e              STR      r6,[r3,#0]
;;;729    			I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
000114  2608              MOVS     r6,#8
000116  619e              STR      r6,[r3,#0x18]
;;;730    			Ret = I2C_STA_STO_RECV;
000118  2020              MOVS     r0,#0x20
;;;731    			break;
00011a  e005              B        |L18.296|
                  |L18.284|
;;;732    		
;;;733    		/* No status information */
;;;734    		case I2C_I2STAT_NO_INF:
00011c  bf00              NOP      
;;;735    		/* Other status must be captured */
;;;736    		default:
;;;737    			I2Cx->I2CONSET = I2C_I2CONSET_AA;
00011e  2604              MOVS     r6,#4
000120  601e              STR      r6,[r3,#0]
;;;738    			I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
000122  2608              MOVS     r6,#8
000124  619e              STR      r6,[r3,#0x18]
;;;739    			break;
000126  bf00              NOP      
                  |L18.296|
000128  bf00              NOP                            ;606
;;;740    		
;;;741    	}
;;;742    
;;;743    	return Ret;
;;;744    }
00012a  bdf0              POP      {r4-r7,pc}
;;;745    /*********************************************************************//**
                          ENDP


                          AREA ||i.I2C_SlaveTransferComplete||, CODE, READONLY, ALIGN=2

                  I2C_SlaveTransferComplete PROC
;;;1322    **********************************************************************/
;;;1323   uint32_t I2C_SlaveTransferComplete(LPC_I2C_TypeDef *I2Cx)
000000  b570              PUSH     {r4-r6,lr}
;;;1324   {
000002  4605              MOV      r5,r0
;;;1325   	uint32_t retval, tmp;
;;;1326   	tmp = I2C_getNum(I2Cx);
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       I2C_getNum
00000a  4604              MOV      r4,r0
;;;1327   	retval = I2C_SlaveComplete[tmp];
00000c  4804              LDR      r0,|L19.32|
00000e  f8506024          LDR      r6,[r0,r4,LSL #2]
;;;1328   	I2C_SlaveComplete[tmp] = FALSE;
000012  2000              MOVS     r0,#0
000014  4902              LDR      r1,|L19.32|
000016  f8410024          STR      r0,[r1,r4,LSL #2]
;;;1329   	return retval;
00001a  4630              MOV      r0,r6
;;;1330   }
00001c  bd70              POP      {r4-r6,pc}
;;;1331   
                          ENDP

00001e  0000              DCW      0x0000
                  |L19.32|
                          DCD      I2C_SlaveComplete

                          AREA ||i.I2C_SlaveTransferData||, CODE, READONLY, ALIGN=2

                  I2C_SlaveTransferData PROC
;;;1035    **********************************************************************/
;;;1036   Status I2C_SlaveTransferData(LPC_I2C_TypeDef *I2Cx, I2C_S_SETUP_Type *TransferCfg, \
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1037   								I2C_TRANSFER_OPT_Type Opt)
;;;1038   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
;;;1039   	int32_t   Ret = I2C_OK;
00000a  f04f0800          MOV      r8,#0
;;;1040   	
;;;1041   	uint32_t CodeStatus;
;;;1042   	uint32_t timeout;
;;;1043   	int32_t time_en;
;;;1044   	uint32_t i2cId = I2C_getNum(I2Cx);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       I2C_getNum
000014  4683              MOV      r11,r0
;;;1045   	// Reset I2C setup value to default state
;;;1046   	TransferCfg->tx_count = 0;
000016  2000              MOVS     r0,#0
000018  60a8              STR      r0,[r5,#8]
;;;1047   	TransferCfg->rx_count = 0;
00001a  6168              STR      r0,[r5,#0x14]
;;;1048   	TransferCfg->status = 0;
00001c  61a8              STR      r0,[r5,#0x18]
;;;1049   
;;;1050   	// Polling option
;;;1051   	if (Opt == I2C_TRANSFER_POLLING)
00001e  2f00              CMP      r7,#0
000020  d13f              BNE      |L20.162|
;;;1052   	{
;;;1053   		/* Set AA bit to ACK command on I2C bus */
;;;1054   		I2Cx->I2CONSET = I2C_I2CONSET_AA;
000022  2004              MOVS     r0,#4
000024  6020              STR      r0,[r4,#0]
;;;1055   		
;;;1056   		/* Clear SI bit to be ready ... */
;;;1057   		I2Cx->I2CONCLR = (I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC|I2C_I2CONCLR_STOC);
000026  2038              MOVS     r0,#0x38
000028  61a0              STR      r0,[r4,#0x18]
;;;1058   
;;;1059   		time_en = 0;
00002a  f04f0a00          MOV      r10,#0
;;;1060   		timeout = 0;
00002e  f04f0900          MOV      r9,#0
;;;1061   
;;;1062   		while (1)
000032  e028              B        |L20.134|
                  |L20.52|
;;;1063   		{
;;;1064   			/* Check SI flag ready */
;;;1065   			if (I2Cx->I2CONSET & I2C_I2CONSET_SI)
000034  6820              LDR      r0,[r4,#0]
000036  f0000008          AND      r0,r0,#8
00003a  b1d0              CBZ      r0,|L20.114|
;;;1066   			{
;;;1067   				time_en = 0;
00003c  f04f0a00          MOV      r10,#0
;;;1068   
;;;1069   				CodeStatus = (I2Cx->I2STAT & I2C_STAT_CODE_BITMASK);
000040  6860              LDR      r0,[r4,#4]
000042  f00006f8          AND      r6,r0,#0xf8
;;;1070   
;;;1071   				Ret = I2C_SlaveHanleStates(I2Cx, CodeStatus, TransferCfg);
000046  462a              MOV      r2,r5
000048  4631              MOV      r1,r6
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       I2C_SlaveHanleStates
000050  4680              MOV      r8,r0
;;;1072   				if(I2C_CheckError(Ret))
000052  f0085080          AND      r0,r8,#0x10000000
000056  b100              CBZ      r0,|L20.90|
;;;1073   				{
;;;1074   					goto s_error;
000058  e01e              B        |L20.152|
                  |L20.90|
;;;1075   				}
;;;1076   				else if(Ret & I2C_STA_STO_RECV)
00005a  f0080020          AND      r0,r8,#0x20
00005e  b120              CBZ      r0,|L20.106|
;;;1077   				{
;;;1078   					time_en = 1;
000060  f04f0a01          MOV      r10,#1
;;;1079   					timeout = 0;
000064  f04f0900          MOV      r9,#0
000068  e00d              B        |L20.134|
                  |L20.106|
;;;1080   				}
;;;1081                   else if (Ret & I2C_SEND_END)
00006a  f0080008          AND      r0,r8,#8
00006e  b150              CBZ      r0,|L20.134|
;;;1082                   {
;;;1083                       goto s_end_stage;
000070  e00a              B        |L20.136|
                  |L20.114|
;;;1084                   }
;;;1085   			}
;;;1086   			else if (time_en)
000072  f1ba0f00          CMP      r10,#0
000076  d006              BEQ      |L20.134|
;;;1087   			{
;;;1088   				if (timeout++ > I2C_SLAVE_TIME_OUT)
000078  4648              MOV      r0,r9
00007a  f1090901          ADD      r9,r9,#1
00007e  f5b03f80          CMP      r0,#0x10000
000082  d900              BLS      |L20.134|
;;;1089   				{
;;;1090   					// it's really a stop condition, goto end stage
;;;1091   					goto s_end_stage;
000084  e000              B        |L20.136|
                  |L20.134|
000086  e7d5              B        |L20.52|
                  |L20.136|
;;;1092   				}
;;;1093   			}
;;;1094   		}
;;;1095   
;;;1096   s_end_stage:
;;;1097   		/* Clear AA bit to disable ACK on I2C bus */
;;;1098   		I2Cx->I2CONCLR = I2C_I2CONCLR_AAC;
000088  2004              MOVS     r0,#4
00008a  61a0              STR      r0,[r4,#0x18]
;;;1099   
;;;1100   		// Check if there's no error during operation
;;;1101   		// Update status
;;;1102   		TransferCfg->status = CodeStatus | I2C_SETUP_STATUS_DONE;
00008c  f4466080          ORR      r0,r6,#0x400
000090  61a8              STR      r0,[r5,#0x18]
;;;1103   		return SUCCESS;
000092  2001              MOVS     r0,#1
                  |L20.148|
;;;1104   
;;;1105   s_error:
;;;1106   		/* Clear AA bit to disable ACK on I2C bus */
;;;1107   		I2Cx->I2CONCLR = I2C_I2CONCLR_AAC;
;;;1108   
;;;1109   		// Update status
;;;1110   		TransferCfg->status = CodeStatus;
;;;1111   		return ERROR;
;;;1112   	}
;;;1113   
;;;1114   	else if (Opt == I2C_TRANSFER_INTERRUPT)
;;;1115   	{
;;;1116   		// Setup tx_rx data, callback and interrupt handler
;;;1117   		i2cdat[i2cId].txrx_setup = (uint32_t) TransferCfg;
;;;1118   
;;;1119   		// Set direction phase, read first
;;;1120   		i2cdat[i2cId].dir = 1;
;;;1121   
;;;1122   		// Enable AA
;;;1123   		I2Cx->I2CONSET = I2C_I2CONSET_AA;
;;;1124   		I2Cx->I2CONCLR = I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC;
;;;1125   		I2C_IntCmd(I2Cx, TRUE);
;;;1126   
;;;1127   		return (SUCCESS);
;;;1128   	}
;;;1129   
;;;1130   	return ERROR;
;;;1131   }
000094  e8bd9ff0          POP      {r4-r12,pc}
                  |L20.152|
000098  2004              MOVS     r0,#4                 ;1107
00009a  61a0              STR      r0,[r4,#0x18]         ;1107
00009c  61ae              STR      r6,[r5,#0x18]         ;1110
00009e  2000              MOVS     r0,#0                 ;1111
0000a0  e7f8              B        |L20.148|
                  |L20.162|
0000a2  2f01              CMP      r7,#1                 ;1114
0000a4  d111              BNE      |L20.202|
0000a6  480a              LDR      r0,|L20.208|
0000a8  f840503b          STR      r5,[r0,r11,LSL #3]    ;1117
0000ac  2001              MOVS     r0,#1                 ;1120
0000ae  4908              LDR      r1,|L20.208|
0000b0  eb0101cb          ADD      r1,r1,r11,LSL #3      ;1120
0000b4  6048              STR      r0,[r1,#4]            ;1120
0000b6  2004              MOVS     r0,#4                 ;1123
0000b8  6020              STR      r0,[r4,#0]            ;1123
0000ba  2028              MOVS     r0,#0x28              ;1124
0000bc  61a0              STR      r0,[r4,#0x18]         ;1124
0000be  2101              MOVS     r1,#1                 ;1125
0000c0  4620              MOV      r0,r4                 ;1125
0000c2  f7fffffe          BL       I2C_IntCmd
0000c6  2001              MOVS     r0,#1                 ;1127
0000c8  e7e4              B        |L20.148|
                  |L20.202|
0000ca  2000              MOVS     r0,#0                 ;1130
0000cc  e7e2              B        |L20.148|
;;;1132   
                          ENDP

0000ce  0000              DCW      0x0000
                  |L20.208|
                          DCD      i2cdat

                          AREA ||i.I2C_Start||, CODE, READONLY, ALIGN=1

                  I2C_Start PROC
;;;134     *********************************************************************/
;;;135    static uint32_t I2C_Start (LPC_I2C_TypeDef *I2Cx)
000000  4601              MOV      r1,r0
;;;136    {
;;;137    	// Reset STA, STO, SI
;;;138    	I2Cx->I2CONCLR = I2C_I2CONCLR_SIC|I2C_I2CONCLR_STOC|I2C_I2CONCLR_STAC;
000002  2038              MOVS     r0,#0x38
000004  6188              STR      r0,[r1,#0x18]
;;;139    
;;;140    	// Enter to Master Transmitter mode
;;;141    	I2Cx->I2CONSET = I2C_I2CONSET_STA;
000006  2020              MOVS     r0,#0x20
000008  6008              STR      r0,[r1,#0]
;;;142    
;;;143    	// Wait for complete
;;;144    	while (!(I2Cx->I2CONSET & I2C_I2CONSET_SI));
00000a  bf00              NOP      
                  |L21.12|
00000c  6808              LDR      r0,[r1,#0]
00000e  f0000008          AND      r0,r0,#8
000012  2800              CMP      r0,#0
000014  d0fa              BEQ      |L21.12|
;;;145    	I2Cx->I2CONCLR = I2C_I2CONCLR_STAC;
000016  2020              MOVS     r0,#0x20
000018  6188              STR      r0,[r1,#0x18]
;;;146    	return (I2Cx->I2STAT & I2C_STAT_CODE_BITMASK);
00001a  6848              LDR      r0,[r1,#4]
00001c  f00000f8          AND      r0,r0,#0xf8
;;;147    }
000020  4770              BX       lr
;;;148    
                          ENDP


                          AREA ||i.I2C_Stop||, CODE, READONLY, ALIGN=1

                  I2C_Stop PROC
;;;156     *********************************************************************/
;;;157    static void I2C_Stop (LPC_I2C_TypeDef *I2Cx)
000000  6801              LDR      r1,[r0,#0]
;;;158    {
;;;159    
;;;160    	/* Make sure start bit is not active */
;;;161    	if (I2Cx->I2CONSET & I2C_I2CONSET_STA)
000002  f0010120          AND      r1,r1,#0x20
000006  b109              CBZ      r1,|L22.12|
;;;162    	{
;;;163    		I2Cx->I2CONCLR = I2C_I2CONCLR_STAC;
000008  2120              MOVS     r1,#0x20
00000a  6181              STR      r1,[r0,#0x18]
                  |L22.12|
;;;164    	}
;;;165    
;;;166    	I2Cx->I2CONSET = I2C_I2CONSET_STO|I2C_I2CONSET_AA;
00000c  2114              MOVS     r1,#0x14
00000e  6001              STR      r1,[r0,#0]
;;;167    
;;;168    	I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
000010  2108              MOVS     r1,#8
000012  6181              STR      r1,[r0,#0x18]
;;;169    }
000014  4770              BX       lr
;;;170    
                          ENDP


                          AREA ||i.I2C_getNum||, CODE, READONLY, ALIGN=2

                  I2C_getNum PROC
;;;115     *********************************************************************/
;;;116    static int32_t I2C_getNum(LPC_I2C_TypeDef *I2Cx){
000000  4601              MOV      r1,r0
;;;117    	if (I2Cx == LPC_I2C0) {
000002  4809              LDR      r0,|L23.40|
000004  4281              CMP      r1,r0
000006  d101              BNE      |L23.12|
;;;118    		return (0);
000008  2000              MOVS     r0,#0
                  |L23.10|
;;;119    	} else if (I2Cx == LPC_I2C1) {
;;;120    		return (1);
;;;121    	} else if (I2Cx == LPC_I2C2) {
;;;122    		return (2);
;;;123    	}
;;;124    	return (-1);
;;;125    }
00000a  4770              BX       lr
                  |L23.12|
00000c  4807              LDR      r0,|L23.44|
00000e  4281              CMP      r1,r0                 ;119
000010  d101              BNE      |L23.22|
000012  2001              MOVS     r0,#1                 ;120
000014  e7f9              B        |L23.10|
                  |L23.22|
000016  4806              LDR      r0,|L23.48|
000018  4281              CMP      r1,r0                 ;121
00001a  d101              BNE      |L23.32|
00001c  2002              MOVS     r0,#2                 ;122
00001e  e7f4              B        |L23.10|
                  |L23.32|
000020  f04f30ff          MOV      r0,#0xffffffff        ;124
000024  e7f1              B        |L23.10|
;;;126    
                          ENDP

000026  0000              DCW      0x0000
                  |L23.40|
                          DCD      0x4001c000
                  |L23.44|
                          DCD      0x4005c000
                  |L23.48|
                          DCD      0x400a0000

                          AREA ||i.NVIC_DisableIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_DisableIRQ PROC
;;;1345    */
;;;1346   __STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1347   {
;;;1348     NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a02              LDR      r2,|L24.20|
00000a  0943              LSRS     r3,r0,#5
00000c  f8421023          STR      r1,[r2,r3,LSL #2]
;;;1349   }
000010  4770              BX       lr
;;;1350   
                          ENDP

000012  0000              DCW      0x0000
                  |L24.20|
                          DCD      0xe000e180

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1333    */
;;;1334   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1335   {
;;;1336     NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0942              LSRS     r2,r0,#5
00000a  0092              LSLS     r2,r2,#2
00000c  f10222e0          ADD      r2,r2,#0xe000e000
000010  f8c21100          STR      r1,[r2,#0x100]
;;;1337   }
000014  4770              BX       lr
;;;1338   
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  i2cdat
                          %        24
                  I2C_MasterComplete
                          %        12
                  I2C_SlaveComplete
                          %        12

                          AREA ||.data||, DATA, ALIGN=2

                  I2C_MonitorBufferIndex
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "Lib\\Drivers\\source\\lpc17xx_i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_lpc17xx_i2c_c_I2C_Init____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_lpc17xx_i2c_c_I2C_Init____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_lpc17xx_i2c_c_I2C_Init____REVSH|
#line 144
|__asm___13_lpc17xx_i2c_c_I2C_Init____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
