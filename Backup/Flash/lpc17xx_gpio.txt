; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\lpc17xx_gpio.o --asm_dir=.\Flash\ --list_dir=.\Flash\ --depend=.\flash\lpc17xx_gpio.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\Lib\Drivers\include -I.\Inc -I.\Lib\Usb_Drivers\Inc -I.\Lib\CLib__1_0_0_4\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\NXP\LPC17xx -D__UVISION_VERSION=525 --omf_browse=.\flash\lpc17xx_gpio.crf Lib\Drivers\source\lpc17xx_gpio.c]
                          THUMB

                          AREA ||i.FIO_ByteClearValue||, CODE, READONLY, ALIGN=1

                  FIO_ByteClearValue PROC
;;;720     **********************************************************************/
;;;721    void FIO_ByteClearValue(uint8_t portNum, uint8_t byteNum, uint8_t bitValue)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;722    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;723    	GPIO_Byte_TypeDef *pFIO = FIO_ByteGetPointer(portNum);
00000a  4638              MOV      r0,r7
00000c  f7fffffe          BL       FIO_ByteGetPointer
000010  4606              MOV      r6,r0
;;;724    	if (pFIO != NULL) {
000012  b126              CBZ      r6,|L1.30|
;;;725    		if (byteNum <= 3){
000014  2c03              CMP      r4,#3
000016  dc02              BGT      |L1.30|
;;;726    			pFIO->FIOCLR[byteNum] = bitValue;
000018  f106001c          ADD      r0,r6,#0x1c
00001c  5505              STRB     r5,[r0,r4]
                  |L1.30|
;;;727    		}
;;;728    	}
;;;729    }
00001e  e8bd81f0          POP      {r4-r8,pc}
;;;730    
                          ENDP


                          AREA ||i.FIO_ByteGetPointer||, CODE, READONLY, ALIGN=2

                  FIO_ByteGetPointer PROC
;;;130     **********************************************************************/
;;;131    static GPIO_Byte_TypeDef *FIO_ByteGetPointer(uint8_t portNum)
000000  4601              MOV      r1,r0
;;;132    {
;;;133    	GPIO_Byte_TypeDef *pFIO = NULL;
000002  2000              MOVS     r0,#0
;;;134    
;;;135    	switch (portNum) {
000004  2905              CMP      r1,#5
000006  d212              BCS      |L2.46|
000008  e8dff001          TBB      [pc,r1]
00000c  0305080b          DCB      0x03,0x05,0x08,0x0b
000010  0e00              DCB      0x0e,0x00
;;;136    	case 0:
;;;137    		pFIO = GPIO0_Byte;
000012  4808              LDR      r0,|L2.52|
;;;138    		break;
000014  e00c              B        |L2.48|
;;;139    	case 1:
;;;140    		pFIO = GPIO1_Byte;
000016  4807              LDR      r0,|L2.52|
000018  3020              ADDS     r0,r0,#0x20
;;;141    		break;
00001a  e009              B        |L2.48|
;;;142    	case 2:
;;;143    		pFIO = GPIO2_Byte;
00001c  4805              LDR      r0,|L2.52|
00001e  3040              ADDS     r0,r0,#0x40
;;;144    		break;
000020  e006              B        |L2.48|
;;;145    	case 3:
;;;146    		pFIO = GPIO3_Byte;
000022  4804              LDR      r0,|L2.52|
000024  3060              ADDS     r0,r0,#0x60
;;;147    		break;
000026  e003              B        |L2.48|
;;;148    	case 4:
;;;149    		pFIO = GPIO4_Byte;
000028  4802              LDR      r0,|L2.52|
00002a  3080              ADDS     r0,r0,#0x80
;;;150    		break;
00002c  e000              B        |L2.48|
                  |L2.46|
;;;151    	default:
;;;152    		break;
00002e  bf00              NOP      
                  |L2.48|
000030  bf00              NOP                            ;138
;;;153    	}
;;;154    
;;;155    	return pFIO;
;;;156    }
000032  4770              BX       lr
;;;157    
                          ENDP

                  |L2.52|
                          DCD      0x2009c000

                          AREA ||i.FIO_ByteReadValue||, CODE, READONLY, ALIGN=1

                  FIO_ByteReadValue PROC
;;;740     **********************************************************************/
;;;741    uint8_t FIO_ByteReadValue(uint8_t portNum, uint8_t byteNum)
000000  b570              PUSH     {r4-r6,lr}
;;;742    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;743    	GPIO_Byte_TypeDef *pFIO = FIO_ByteGetPointer(portNum);
000006  4630              MOV      r0,r6
000008  f7fffffe          BL       FIO_ByteGetPointer
00000c  4605              MOV      r5,r0
;;;744    	if (pFIO != NULL) {
00000e  b12d              CBZ      r5,|L3.28|
;;;745    		if (byteNum <= 3){
000010  2c03              CMP      r4,#3
000012  dc03              BGT      |L3.28|
;;;746    			return (pFIO->FIOPIN[byteNum]);
000014  f1050014          ADD      r0,r5,#0x14
000018  5d00              LDRB     r0,[r0,r4]
                  |L3.26|
;;;747    		}
;;;748    	}
;;;749    	return (0);
;;;750    }
00001a  bd70              POP      {r4-r6,pc}
                  |L3.28|
00001c  2000              MOVS     r0,#0                 ;749
00001e  e7fc              B        |L3.26|
;;;751    
                          ENDP


                          AREA ||i.FIO_ByteSetDir||, CODE, READONLY, ALIGN=1

                  FIO_ByteSetDir PROC
;;;623     **********************************************************************/
;;;624    void FIO_ByteSetDir(uint8_t portNum, uint8_t byteNum, uint8_t bitValue, uint8_t dir)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;625    {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;626    	GPIO_Byte_TypeDef *pFIO = FIO_ByteGetPointer(portNum);
00000c  4640              MOV      r0,r8
00000e  f7fffffe          BL       FIO_ByteGetPointer
000012  4605              MOV      r5,r0
;;;627    	if(pFIO != NULL) {
000014  b15d              CBZ      r5,|L4.46|
;;;628    		// Output direction
;;;629    		if (dir) {
000016  b12f              CBZ      r7,|L4.36|
;;;630    			if (byteNum <= 3) {
000018  2c03              CMP      r4,#3
00001a  dc08              BGT      |L4.46|
;;;631    				pFIO->FIODIR[byteNum] |= bitValue;
00001c  5d28              LDRB     r0,[r5,r4]
00001e  4330              ORRS     r0,r0,r6
000020  5528              STRB     r0,[r5,r4]
000022  e004              B        |L4.46|
                  |L4.36|
;;;632    			}
;;;633    		}
;;;634    		// Input direction
;;;635    		else {
;;;636    			if (byteNum <= 3) {
000024  2c03              CMP      r4,#3
000026  dc02              BGT      |L4.46|
;;;637    				pFIO->FIODIR[byteNum] &= ~bitValue;
000028  5d28              LDRB     r0,[r5,r4]
00002a  43b0              BICS     r0,r0,r6
00002c  5528              STRB     r0,[r5,r4]
                  |L4.46|
;;;638    			}
;;;639    		}
;;;640    	}
;;;641    }
00002e  e8bd81f0          POP      {r4-r8,pc}
;;;642    
                          ENDP


                          AREA ||i.FIO_ByteSetMask||, CODE, READONLY, ALIGN=1

                  FIO_ByteSetMask PROC
;;;661     **********************************************************************/
;;;662    void FIO_ByteSetMask(uint8_t portNum, uint8_t byteNum, uint8_t bitValue, uint8_t maskValue)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;663    {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;664    	GPIO_Byte_TypeDef *pFIO = FIO_ByteGetPointer(portNum);
00000c  4640              MOV      r0,r8
00000e  f7fffffe          BL       FIO_ByteGetPointer
000012  4605              MOV      r5,r0
;;;665    	if(pFIO != NULL) {
000014  b19d              CBZ      r5,|L5.62|
;;;666    		// Mask
;;;667    		if (maskValue) {
000016  b14f              CBZ      r7,|L5.44|
;;;668    			if (byteNum <= 3) {
000018  2c03              CMP      r4,#3
00001a  dc10              BGT      |L5.62|
;;;669    				pFIO->FIOMASK[byteNum] |= bitValue;
00001c  f1050010          ADD      r0,r5,#0x10
000020  5d00              LDRB     r0,[r0,r4]
000022  4330              ORRS     r0,r0,r6
000024  f1050110          ADD      r1,r5,#0x10
000028  5508              STRB     r0,[r1,r4]
00002a  e008              B        |L5.62|
                  |L5.44|
;;;670    			}
;;;671    		}
;;;672    		// Un-mask
;;;673    		else {
;;;674    			if (byteNum <= 3) {
00002c  2c03              CMP      r4,#3
00002e  dc06              BGT      |L5.62|
;;;675    				pFIO->FIOMASK[byteNum] &= ~bitValue;
000030  f1050010          ADD      r0,r5,#0x10
000034  5d00              LDRB     r0,[r0,r4]
000036  43b0              BICS     r0,r0,r6
000038  f1050110          ADD      r1,r5,#0x10
00003c  5508              STRB     r0,[r1,r4]
                  |L5.62|
;;;676    			}
;;;677    		}
;;;678    	}
;;;679    }
00003e  e8bd81f0          POP      {r4-r8,pc}
;;;680    
                          ENDP


                          AREA ||i.FIO_ByteSetValue||, CODE, READONLY, ALIGN=1

                  FIO_ByteSetValue PROC
;;;695     **********************************************************************/
;;;696    void FIO_ByteSetValue(uint8_t portNum, uint8_t byteNum, uint8_t bitValue)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;697    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;698    	GPIO_Byte_TypeDef *pFIO = FIO_ByteGetPointer(portNum);
00000a  4638              MOV      r0,r7
00000c  f7fffffe          BL       FIO_ByteGetPointer
000010  4606              MOV      r6,r0
;;;699    	if (pFIO != NULL) {
000012  b126              CBZ      r6,|L6.30|
;;;700    		if (byteNum <= 3){
000014  2c03              CMP      r4,#3
000016  dc02              BGT      |L6.30|
;;;701    			pFIO->FIOSET[byteNum] = bitValue;
000018  f1060018          ADD      r0,r6,#0x18
00001c  5505              STRB     r5,[r0,r4]
                  |L6.30|
;;;702    		}
;;;703    	}
;;;704    }
00001e  e8bd81f0          POP      {r4-r8,pc}
;;;705    
                          ENDP


                          AREA ||i.FIO_ClearInt||, CODE, READONLY, ALIGN=1

                  FIO_ClearInt PROC
;;;388     */
;;;389    void FIO_ClearInt(uint8_t portNum, uint32_t bitValue)
000000  b510              PUSH     {r4,lr}
;;;390    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;391    	GPIO_ClearInt(portNum, bitValue);
000006  4621              MOV      r1,r4
000008  4618              MOV      r0,r3
00000a  f7fffffe          BL       GPIO_ClearInt
;;;392    }
00000e  bd10              POP      {r4,pc}
;;;393    /*********************************************************************//**
                          ENDP


                          AREA ||i.FIO_ClearValue||, CODE, READONLY, ALIGN=1

                  FIO_ClearValue PROC
;;;356     */
;;;357    void FIO_ClearValue(uint8_t portNum, uint32_t bitValue)
000000  b570              PUSH     {r4-r6,lr}
;;;358    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;359    	GPIO_ClearValue(portNum, bitValue);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_ClearValue
;;;360    }
00000e  bd70              POP      {r4-r6,pc}
;;;361    
                          ENDP


                          AREA ||i.FIO_GetIntStatus||, CODE, READONLY, ALIGN=1

                  FIO_GetIntStatus PROC
;;;380     */
;;;381    FunctionalState FIO_GetIntStatus(uint8_t portNum, uint32_t pinNum, uint8_t edgeState)
000000  b570              PUSH     {r4-r6,lr}
;;;382    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;383    	return (GPIO_GetIntStatus(portNum, pinNum, edgeState));
000008  4632              MOV      r2,r6
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       GPIO_GetIntStatus
;;;384    }
000012  bd70              POP      {r4-r6,pc}
;;;385    
                          ENDP


                          AREA ||i.FIO_HalfWordClearValue||, CODE, READONLY, ALIGN=1

                  FIO_HalfWordClearValue PROC
;;;565     **********************************************************************/
;;;566    void FIO_HalfWordClearValue(uint8_t portNum, uint8_t halfwordNum, uint16_t bitValue)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;567    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;568    	GPIO_HalfWord_TypeDef *pFIO = FIO_HalfWordGetPointer(portNum);
00000a  4638              MOV      r0,r7
00000c  f7fffffe          BL       FIO_HalfWordGetPointer
000010  4605              MOV      r5,r0
;;;569    	if(pFIO != NULL) {
000012  b11d              CBZ      r5,|L10.28|
;;;570    		// Upper
;;;571    		if(halfwordNum) {
000014  b10e              CBZ      r6,|L10.26|
;;;572    			pFIO->FIOCLRU = bitValue;
000016  83ec              STRH     r4,[r5,#0x1e]
000018  e000              B        |L10.28|
                  |L10.26|
;;;573    		}
;;;574    		// lower
;;;575    		else {
;;;576    			pFIO->FIOCLRL = bitValue;
00001a  83ac              STRH     r4,[r5,#0x1c]
                  |L10.28|
;;;577    		}
;;;578    	}
;;;579    }
00001c  e8bd81f0          POP      {r4-r8,pc}
;;;580    
                          ENDP


                          AREA ||i.FIO_HalfWordGetPointer||, CODE, READONLY, ALIGN=2

                  FIO_HalfWordGetPointer PROC
;;;97      **********************************************************************/
;;;98     static GPIO_HalfWord_TypeDef *FIO_HalfWordGetPointer(uint8_t portNum)
000000  4601              MOV      r1,r0
;;;99     {
;;;100    	GPIO_HalfWord_TypeDef *pFIO = NULL;
000002  2000              MOVS     r0,#0
;;;101    
;;;102    	switch (portNum) {
000004  2905              CMP      r1,#5
000006  d212              BCS      |L11.46|
000008  e8dff001          TBB      [pc,r1]
00000c  0305080b          DCB      0x03,0x05,0x08,0x0b
000010  0e00              DCB      0x0e,0x00
;;;103    	case 0:
;;;104    		pFIO = GPIO0_HalfWord;
000012  4808              LDR      r0,|L11.52|
;;;105    		break;
000014  e00c              B        |L11.48|
;;;106    	case 1:
;;;107    		pFIO = GPIO1_HalfWord;
000016  4807              LDR      r0,|L11.52|
000018  3020              ADDS     r0,r0,#0x20
;;;108    		break;
00001a  e009              B        |L11.48|
;;;109    	case 2:
;;;110    		pFIO = GPIO2_HalfWord;
00001c  4805              LDR      r0,|L11.52|
00001e  3040              ADDS     r0,r0,#0x40
;;;111    		break;
000020  e006              B        |L11.48|
;;;112    	case 3:
;;;113    		pFIO = GPIO3_HalfWord;
000022  4804              LDR      r0,|L11.52|
000024  3060              ADDS     r0,r0,#0x60
;;;114    		break;
000026  e003              B        |L11.48|
;;;115    	case 4:
;;;116    		pFIO = GPIO4_HalfWord;
000028  4802              LDR      r0,|L11.52|
00002a  3080              ADDS     r0,r0,#0x80
;;;117    		break;
00002c  e000              B        |L11.48|
                  |L11.46|
;;;118    	default:
;;;119    		break;
00002e  bf00              NOP      
                  |L11.48|
000030  bf00              NOP                            ;105
;;;120    	}
;;;121    
;;;122    	return pFIO;
;;;123    }
000032  4770              BX       lr
;;;124    
                          ENDP

                  |L11.52|
                          DCD      0x2009c000

                          AREA ||i.FIO_HalfWordReadValue||, CODE, READONLY, ALIGN=1

                  FIO_HalfWordReadValue PROC
;;;590     **********************************************************************/
;;;591    uint16_t FIO_HalfWordReadValue(uint8_t portNum, uint8_t halfwordNum)
000000  b570              PUSH     {r4-r6,lr}
;;;592    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;593    	GPIO_HalfWord_TypeDef *pFIO = FIO_HalfWordGetPointer(portNum);
000006  4630              MOV      r0,r6
000008  f7fffffe          BL       FIO_HalfWordGetPointer
00000c  4604              MOV      r4,r0
;;;594    	if(pFIO != NULL) {
00000e  b124              CBZ      r4,|L12.26|
;;;595    		// Upper
;;;596    		if(halfwordNum) {
000010  b10d              CBZ      r5,|L12.22|
;;;597    			return (pFIO->FIOPINU);
000012  8ae0              LDRH     r0,[r4,#0x16]
                  |L12.20|
;;;598    		}
;;;599    		// lower
;;;600    		else {
;;;601    			return (pFIO->FIOPINL);
;;;602    		}
;;;603    	}
;;;604    	return (0);
;;;605    }
000014  bd70              POP      {r4-r6,pc}
                  |L12.22|
000016  8aa0              LDRH     r0,[r4,#0x14]         ;601
000018  e7fc              B        |L12.20|
                  |L12.26|
00001a  2000              MOVS     r0,#0                 ;604
00001c  e7fa              B        |L12.20|
;;;606    
                          ENDP


                          AREA ||i.FIO_HalfWordSetDir||, CODE, READONLY, ALIGN=1

                  FIO_HalfWordSetDir PROC
;;;442     **********************************************************************/
;;;443    void FIO_HalfWordSetDir(uint8_t portNum, uint8_t halfwordNum, uint16_t bitValue, uint8_t dir)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;444    {
000004  4680              MOV      r8,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
;;;445    	GPIO_HalfWord_TypeDef *pFIO = FIO_HalfWordGetPointer(portNum);
00000c  4640              MOV      r0,r8
00000e  f7fffffe          BL       FIO_HalfWordGetPointer
000012  4604              MOV      r4,r0
;;;446    	if(pFIO != NULL) {
000014  b18c              CBZ      r4,|L13.58|
;;;447    		// Output direction
;;;448    		if (dir) {
000016  b147              CBZ      r7,|L13.42|
;;;449    			// Upper
;;;450    			if(halfwordNum) {
000018  b11e              CBZ      r6,|L13.34|
;;;451    				pFIO->FIODIRU |= bitValue;
00001a  8860              LDRH     r0,[r4,#2]
00001c  4328              ORRS     r0,r0,r5
00001e  8060              STRH     r0,[r4,#2]
000020  e00b              B        |L13.58|
                  |L13.34|
;;;452    			}
;;;453    			// lower
;;;454    			else {
;;;455    				pFIO->FIODIRL |= bitValue;
000022  8820              LDRH     r0,[r4,#0]
000024  4328              ORRS     r0,r0,r5
000026  8020              STRH     r0,[r4,#0]
000028  e007              B        |L13.58|
                  |L13.42|
;;;456    			}
;;;457    		}
;;;458    		// Input direction
;;;459    		else {
;;;460    			// Upper
;;;461    			if(halfwordNum) {
00002a  b11e              CBZ      r6,|L13.52|
;;;462    				pFIO->FIODIRU &= ~bitValue;
00002c  8860              LDRH     r0,[r4,#2]
00002e  43a8              BICS     r0,r0,r5
000030  8060              STRH     r0,[r4,#2]
000032  e002              B        |L13.58|
                  |L13.52|
;;;463    			}
;;;464    			// lower
;;;465    			else {
;;;466    				pFIO->FIODIRL &= ~bitValue;
000034  8820              LDRH     r0,[r4,#0]
000036  43a8              BICS     r0,r0,r5
000038  8020              STRH     r0,[r4,#0]
                  |L13.58|
;;;467    			}
;;;468    		}
;;;469    	}
;;;470    }
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;471    
                          ENDP


                          AREA ||i.FIO_HalfWordSetMask||, CODE, READONLY, ALIGN=1

                  FIO_HalfWordSetMask PROC
;;;491     **********************************************************************/
;;;492    void FIO_HalfWordSetMask(uint8_t portNum, uint8_t halfwordNum, uint16_t bitValue, uint8_t maskValue)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;493    {
000004  4680              MOV      r8,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
;;;494    	GPIO_HalfWord_TypeDef *pFIO = FIO_HalfWordGetPointer(portNum);
00000c  4640              MOV      r0,r8
00000e  f7fffffe          BL       FIO_HalfWordGetPointer
000012  4604              MOV      r4,r0
;;;495    	if(pFIO != NULL) {
000014  b18c              CBZ      r4,|L14.58|
;;;496    		// Mask
;;;497    		if (maskValue){
000016  b147              CBZ      r7,|L14.42|
;;;498    			// Upper
;;;499    			if(halfwordNum) {
000018  b11e              CBZ      r6,|L14.34|
;;;500    				pFIO->FIOMASKU |= bitValue;
00001a  8a60              LDRH     r0,[r4,#0x12]
00001c  4328              ORRS     r0,r0,r5
00001e  8260              STRH     r0,[r4,#0x12]
000020  e00b              B        |L14.58|
                  |L14.34|
;;;501    			}
;;;502    			// lower
;;;503    			else {
;;;504    				pFIO->FIOMASKL |= bitValue;
000022  8a20              LDRH     r0,[r4,#0x10]
000024  4328              ORRS     r0,r0,r5
000026  8220              STRH     r0,[r4,#0x10]
000028  e007              B        |L14.58|
                  |L14.42|
;;;505    			}
;;;506    		}
;;;507    		// Un-mask
;;;508    		else {
;;;509    			// Upper
;;;510    			if(halfwordNum) {
00002a  b11e              CBZ      r6,|L14.52|
;;;511    				pFIO->FIOMASKU &= ~bitValue;
00002c  8a60              LDRH     r0,[r4,#0x12]
00002e  43a8              BICS     r0,r0,r5
000030  8260              STRH     r0,[r4,#0x12]
000032  e002              B        |L14.58|
                  |L14.52|
;;;512    			}
;;;513    			// lower
;;;514    			else {
;;;515    				pFIO->FIOMASKL &= ~bitValue;
000034  8a20              LDRH     r0,[r4,#0x10]
000036  43a8              BICS     r0,r0,r5
000038  8220              STRH     r0,[r4,#0x10]
                  |L14.58|
;;;516    			}
;;;517    		}
;;;518    	}
;;;519    }
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;520    
                          ENDP


                          AREA ||i.FIO_HalfWordSetValue||, CODE, READONLY, ALIGN=1

                  FIO_HalfWordSetValue PROC
;;;535     **********************************************************************/
;;;536    void FIO_HalfWordSetValue(uint8_t portNum, uint8_t halfwordNum, uint16_t bitValue)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;537    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;538    	GPIO_HalfWord_TypeDef *pFIO = FIO_HalfWordGetPointer(portNum);
00000a  4638              MOV      r0,r7
00000c  f7fffffe          BL       FIO_HalfWordGetPointer
000010  4605              MOV      r5,r0
;;;539    	if(pFIO != NULL) {
000012  b11d              CBZ      r5,|L15.28|
;;;540    		// Upper
;;;541    		if(halfwordNum) {
000014  b10e              CBZ      r6,|L15.26|
;;;542    			pFIO->FIOSETU = bitValue;
000016  836c              STRH     r4,[r5,#0x1a]
000018  e000              B        |L15.28|
                  |L15.26|
;;;543    		}
;;;544    		// lower
;;;545    		else {
;;;546    			pFIO->FIOSETL = bitValue;
00001a  832c              STRH     r4,[r5,#0x18]
                  |L15.28|
;;;547    		}
;;;548    	}
;;;549    }
00001c  e8bd81f0          POP      {r4-r8,pc}
;;;550    
                          ENDP


                          AREA ||i.FIO_IntCmd||, CODE, READONLY, ALIGN=1

                  FIO_IntCmd PROC
;;;372     */
;;;373    void FIO_IntCmd(uint8_t portNum, uint32_t bitValue, uint8_t edgeState)
000000  b570              PUSH     {r4-r6,lr}
;;;374    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;375    	GPIO_IntCmd(portNum, bitValue, edgeState);
000008  4632              MOV      r2,r6
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       GPIO_IntCmd
;;;376    }
000012  bd70              POP      {r4-r6,pc}
;;;377    
                          ENDP


                          AREA ||i.FIO_ReadValue||, CODE, READONLY, ALIGN=1

                  FIO_ReadValue PROC
;;;364     */
;;;365    uint32_t FIO_ReadValue(uint8_t portNum)
000000  b510              PUSH     {r4,lr}
;;;366    {
000002  4604              MOV      r4,r0
;;;367    	return (GPIO_ReadValue(portNum));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       GPIO_ReadValue
;;;368    }
00000a  bd10              POP      {r4,pc}
;;;369    
                          ENDP


                          AREA ||i.FIO_SetDir||, CODE, READONLY, ALIGN=1

                  FIO_SetDir PROC
;;;340     */
;;;341    void FIO_SetDir(uint8_t portNum, uint32_t bitValue, uint8_t dir)
000000  b570              PUSH     {r4-r6,lr}
;;;342    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;343    	GPIO_SetDir(portNum, bitValue, dir);
000008  4632              MOV      r2,r6
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       GPIO_SetDir
;;;344    }
000012  bd70              POP      {r4-r6,pc}
;;;345    
                          ENDP


                          AREA ||i.FIO_SetMask||, CODE, READONLY, ALIGN=1

                  FIO_SetMask PROC
;;;410     **********************************************************************/
;;;411    void FIO_SetMask(uint8_t portNum, uint32_t bitValue, uint8_t maskValue)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;412    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;413    	LPC_GPIO_TypeDef *pFIO = GPIO_GetPointer(portNum);
00000a  4638              MOV      r0,r7
00000c  f7fffffe          BL       GPIO_GetPointer
000010  4604              MOV      r4,r0
;;;414    	if(pFIO != NULL) {
000012  b13c              CBZ      r4,|L19.36|
;;;415    		// Mask
;;;416    		if (maskValue){
000014  b11e              CBZ      r6,|L19.30|
;;;417    			pFIO->FIOMASK |= bitValue;
000016  6920              LDR      r0,[r4,#0x10]
000018  4328              ORRS     r0,r0,r5
00001a  6120              STR      r0,[r4,#0x10]
00001c  e002              B        |L19.36|
                  |L19.30|
;;;418    		}
;;;419    		// Un-mask
;;;420    		else {
;;;421    			pFIO->FIOMASK &= ~bitValue;
00001e  6920              LDR      r0,[r4,#0x10]
000020  43a8              BICS     r0,r0,r5
000022  6120              STR      r0,[r4,#0x10]
                  |L19.36|
;;;422    		}
;;;423    	}
;;;424    }
000024  e8bd81f0          POP      {r4-r8,pc}
;;;425    
                          ENDP


                          AREA ||i.FIO_SetValue||, CODE, READONLY, ALIGN=1

                  FIO_SetValue PROC
;;;348     */
;;;349    void FIO_SetValue(uint8_t portNum, uint32_t bitValue)
000000  b570              PUSH     {r4-r6,lr}
;;;350    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;351    	GPIO_SetValue(portNum, bitValue);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_SetValue
;;;352    }
00000e  bd70              POP      {r4-r6,pc}
;;;353    
                          ENDP


                          AREA ||i.GPIO_ClearInt||, CODE, READONLY, ALIGN=2

                  GPIO_ClearInt PROC
;;;323     **********************************************************************/
;;;324    void GPIO_ClearInt(uint8_t portNum, uint32_t bitValue)
000000  b910              CBNZ     r0,|L21.8|
;;;325    {
;;;326    	if(portNum == 0)
;;;327    		LPC_GPIOINT->IO0IntClr = bitValue;
000002  4a06              LDR      r2,|L21.28|
000004  6011              STR      r1,[r2,#0]
000006  e007              B        |L21.24|
                  |L21.8|
;;;328    	else if (portNum == 2)
000008  2802              CMP      r0,#2
00000a  d103              BNE      |L21.20|
;;;329    		LPC_GPIOINT->IO2IntClr = bitValue;
00000c  4a03              LDR      r2,|L21.28|
00000e  3220              ADDS     r2,r2,#0x20
000010  6011              STR      r1,[r2,#0]
000012  e001              B        |L21.24|
                  |L21.20|
;;;330    	else
;;;331    		//Invalid portNum
;;;332    		while(1);
000014  bf00              NOP      
                  |L21.22|
000016  e7fe              B        |L21.22|
                  |L21.24|
;;;333    }
000018  4770              BX       lr
;;;334    
                          ENDP

00001a  0000              DCW      0x0000
                  |L21.28|
                          DCD      0x4002808c

                          AREA ||i.GPIO_ClearValue||, CODE, READONLY, ALIGN=1

                  GPIO_ClearValue PROC
;;;236     **********************************************************************/
;;;237    void GPIO_ClearValue(uint8_t portNum, uint32_t bitValue)
000000  b570              PUSH     {r4-r6,lr}
;;;238    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;239    	LPC_GPIO_TypeDef *pGPIO = GPIO_GetPointer(portNum);
000006  4630              MOV      r0,r6
000008  f7fffffe          BL       GPIO_GetPointer
00000c  4605              MOV      r5,r0
;;;240    
;;;241    	if (pGPIO != NULL) {
00000e  b105              CBZ      r5,|L22.18|
;;;242    		pGPIO->FIOCLR = bitValue;
000010  61ec              STR      r4,[r5,#0x1c]
                  |L22.18|
;;;243    	}
;;;244    }
000012  bd70              POP      {r4-r6,pc}
;;;245    
                          ENDP


                          AREA ||i.GPIO_GetIntStatus||, CODE, READONLY, ALIGN=2

                  GPIO_GetIntStatus PROC
;;;302     **********************************************************************/
;;;303    FunctionalState GPIO_GetIntStatus(uint8_t portNum, uint32_t pinNum, uint8_t edgeState)
000000  4603              MOV      r3,r0
;;;304    {
;;;305    	if((portNum == 0) && (edgeState == 0))//Rising Edge
000002  b933              CBNZ     r3,|L23.18|
000004  b92a              CBNZ     r2,|L23.18|
;;;306    		return ((FunctionalState)(((LPC_GPIOINT->IO0IntStatR)>>pinNum)& 0x1));
000006  4813              LDR      r0,|L23.84|
000008  6800              LDR      r0,[r0,#0]
00000a  40c8              LSRS     r0,r0,r1
00000c  f0000001          AND      r0,r0,#1
                  |L23.16|
;;;307    	else if ((portNum == 2) && (edgeState == 0))
;;;308    		return ((FunctionalState)(((LPC_GPIOINT->IO2IntStatR)>>pinNum)& 0x1));
;;;309    	else if ((portNum == 0) && (edgeState == 1))//Falling Edge
;;;310    		return ((FunctionalState)(((LPC_GPIOINT->IO0IntStatF)>>pinNum)& 0x1));
;;;311    	else if ((portNum == 2) && (edgeState == 1))
;;;312    		return ((FunctionalState)(((LPC_GPIOINT->IO2IntStatF)>>pinNum)& 0x1));
;;;313    	else
;;;314    		//Error
;;;315    		while(1);
;;;316    }
000010  4770              BX       lr
                  |L23.18|
000012  2b02              CMP      r3,#2                 ;307
000014  d107              BNE      |L23.38|
000016  b932              CBNZ     r2,|L23.38|
000018  480e              LDR      r0,|L23.84|
00001a  3020              ADDS     r0,r0,#0x20           ;308
00001c  6800              LDR      r0,[r0,#0]            ;308
00001e  40c8              LSRS     r0,r0,r1              ;308
000020  f0000001          AND      r0,r0,#1              ;308
000024  e7f4              B        |L23.16|
                  |L23.38|
000026  b943              CBNZ     r3,|L23.58|
000028  2a01              CMP      r2,#1                 ;309
00002a  d106              BNE      |L23.58|
00002c  4809              LDR      r0,|L23.84|
00002e  1d00              ADDS     r0,r0,#4              ;310
000030  6800              LDR      r0,[r0,#0]            ;310
000032  40c8              LSRS     r0,r0,r1              ;310
000034  f0000001          AND      r0,r0,#1              ;310
000038  e7ea              B        |L23.16|
                  |L23.58|
00003a  2b02              CMP      r3,#2                 ;311
00003c  d108              BNE      |L23.80|
00003e  2a01              CMP      r2,#1                 ;311
000040  d106              BNE      |L23.80|
000042  4804              LDR      r0,|L23.84|
000044  3024              ADDS     r0,r0,#0x24           ;312
000046  6800              LDR      r0,[r0,#0]            ;312
000048  40c8              LSRS     r0,r0,r1              ;312
00004a  f0000001          AND      r0,r0,#1              ;312
00004e  e7df              B        |L23.16|
                  |L23.80|
000050  bf00              NOP                            ;315
                  |L23.82|
000052  e7fe              B        |L23.82|
;;;317    /*********************************************************************//**
                          ENDP

                  |L23.84|
                          DCD      0x40028084

                          AREA ||i.GPIO_GetPointer||, CODE, READONLY, ALIGN=2

                  GPIO_GetPointer PROC
;;;64      **********************************************************************/
;;;65     static LPC_GPIO_TypeDef *GPIO_GetPointer(uint8_t portNum)
000000  4601              MOV      r1,r0
;;;66     {
;;;67     	LPC_GPIO_TypeDef *pGPIO = NULL;
000002  2000              MOVS     r0,#0
;;;68     
;;;69     	switch (portNum) {
000004  2905              CMP      r1,#5
000006  d212              BCS      |L24.46|
000008  e8dff001          TBB      [pc,r1]
00000c  0305080b          DCB      0x03,0x05,0x08,0x0b
000010  0e00              DCB      0x0e,0x00
;;;70     	case 0:
;;;71     		pGPIO = LPC_GPIO0;
000012  4808              LDR      r0,|L24.52|
;;;72     		break;
000014  e00c              B        |L24.48|
;;;73     	case 1:
;;;74     		pGPIO = LPC_GPIO1;
000016  4807              LDR      r0,|L24.52|
000018  3020              ADDS     r0,r0,#0x20
;;;75     		break;
00001a  e009              B        |L24.48|
;;;76     	case 2:
;;;77     		pGPIO = LPC_GPIO2;
00001c  4805              LDR      r0,|L24.52|
00001e  3040              ADDS     r0,r0,#0x40
;;;78     		break;
000020  e006              B        |L24.48|
;;;79     	case 3:
;;;80     		pGPIO = LPC_GPIO3;
000022  4804              LDR      r0,|L24.52|
000024  3060              ADDS     r0,r0,#0x60
;;;81     		break;
000026  e003              B        |L24.48|
;;;82     	case 4:
;;;83     		pGPIO = LPC_GPIO4;
000028  4802              LDR      r0,|L24.52|
00002a  3080              ADDS     r0,r0,#0x80
;;;84     		break;
00002c  e000              B        |L24.48|
                  |L24.46|
;;;85     	default:
;;;86     		break;
00002e  bf00              NOP      
                  |L24.48|
000030  bf00              NOP                            ;72
;;;87     	}
;;;88     
;;;89     	return pGPIO;
;;;90     }
000032  4770              BX       lr
;;;91     
                          ENDP

                  |L24.52|
                          DCD      0x2009c000

                          AREA ||i.GPIO_IntCmd||, CODE, READONLY, ALIGN=2

                  GPIO_IntCmd PROC
;;;274     **********************************************************************/
;;;275    void GPIO_IntCmd(uint8_t portNum, uint32_t bitValue, uint8_t edgeState)
000000  b918              CBNZ     r0,|L25.10|
;;;276    {
;;;277    	if((portNum == 0)&&(edgeState == 0))
000002  b912              CBNZ     r2,|L25.10|
;;;278    		LPC_GPIOINT->IO0IntEnR = bitValue;
000004  4b0d              LDR      r3,|L25.60|
000006  6019              STR      r1,[r3,#0]
000008  e017              B        |L25.58|
                  |L25.10|
;;;279    	else if ((portNum == 2)&&(edgeState == 0))
00000a  2802              CMP      r0,#2
00000c  d104              BNE      |L25.24|
00000e  b91a              CBNZ     r2,|L25.24|
;;;280    		LPC_GPIOINT->IO2IntEnR = bitValue;
000010  4b0a              LDR      r3,|L25.60|
000012  3320              ADDS     r3,r3,#0x20
000014  6019              STR      r1,[r3,#0]
000016  e010              B        |L25.58|
                  |L25.24|
;;;281    	else if ((portNum == 0)&&(edgeState == 1))
000018  b928              CBNZ     r0,|L25.38|
00001a  2a01              CMP      r2,#1
00001c  d103              BNE      |L25.38|
;;;282    		LPC_GPIOINT->IO0IntEnF = bitValue;
00001e  4b07              LDR      r3,|L25.60|
000020  1d1b              ADDS     r3,r3,#4
000022  6019              STR      r1,[r3,#0]
000024  e009              B        |L25.58|
                  |L25.38|
;;;283    	else if ((portNum == 2)&&(edgeState == 1))
000026  2802              CMP      r0,#2
000028  d105              BNE      |L25.54|
00002a  2a01              CMP      r2,#1
00002c  d103              BNE      |L25.54|
;;;284    		LPC_GPIOINT->IO2IntEnF = bitValue;
00002e  4b03              LDR      r3,|L25.60|
000030  3324              ADDS     r3,r3,#0x24
000032  6019              STR      r1,[r3,#0]
000034  e001              B        |L25.58|
                  |L25.54|
;;;285    	else
;;;286    		//Error
;;;287    		while(1);
000036  bf00              NOP      
                  |L25.56|
000038  e7fe              B        |L25.56|
                  |L25.58|
;;;288    }
00003a  4770              BX       lr
;;;289    
                          ENDP

                  |L25.60|
                          DCD      0x40028090

                          AREA ||i.GPIO_ReadValue||, CODE, READONLY, ALIGN=1

                  GPIO_ReadValue PROC
;;;253     **********************************************************************/
;;;254    uint32_t GPIO_ReadValue(uint8_t portNum)
000000  b570              PUSH     {r4-r6,lr}
;;;255    {
000002  4605              MOV      r5,r0
;;;256    	LPC_GPIO_TypeDef *pGPIO = GPIO_GetPointer(portNum);
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       GPIO_GetPointer
00000a  4604              MOV      r4,r0
;;;257    
;;;258    	if (pGPIO != NULL) {
00000c  b10c              CBZ      r4,|L26.18|
;;;259    		return pGPIO->FIOPIN;
00000e  6960              LDR      r0,[r4,#0x14]
                  |L26.16|
;;;260    	}
;;;261    
;;;262    	return (0);
;;;263    }
000010  bd70              POP      {r4-r6,pc}
                  |L26.18|
000012  2000              MOVS     r0,#0                 ;262
000014  e7fc              B        |L26.16|
;;;264    
                          ENDP


                          AREA ||i.GPIO_SetDir||, CODE, READONLY, ALIGN=1

                  GPIO_SetDir PROC
;;;182     **********************************************************************/
;;;183    void GPIO_SetDir(uint8_t portNum, uint32_t bitValue, uint8_t dir)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;184    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;185    	LPC_GPIO_TypeDef *pGPIO = GPIO_GetPointer(portNum);
00000a  4638              MOV      r0,r7
00000c  f7fffffe          BL       GPIO_GetPointer
000010  4604              MOV      r4,r0
;;;186    
;;;187    	if (pGPIO != NULL) {
000012  b13c              CBZ      r4,|L27.36|
;;;188    		// Enable Output
;;;189    		if (dir) {
000014  b11e              CBZ      r6,|L27.30|
;;;190    			pGPIO->FIODIR |= bitValue;
000016  6820              LDR      r0,[r4,#0]
000018  4328              ORRS     r0,r0,r5
00001a  6020              STR      r0,[r4,#0]
00001c  e002              B        |L27.36|
                  |L27.30|
;;;191    		}
;;;192    		// Enable Input
;;;193    		else {
;;;194    			pGPIO->FIODIR &= ~bitValue;
00001e  6820              LDR      r0,[r4,#0]
000020  43a8              BICS     r0,r0,r5
000022  6020              STR      r0,[r4,#0]
                  |L27.36|
;;;195    		}
;;;196    	}
;;;197    }
000024  e8bd81f0          POP      {r4-r8,pc}
;;;198    
                          ENDP


                          AREA ||i.GPIO_SetValue||, CODE, READONLY, ALIGN=1

                  GPIO_SetValue PROC
;;;213     **********************************************************************/
;;;214    void GPIO_SetValue(uint8_t portNum, uint32_t bitValue)
000000  b570              PUSH     {r4-r6,lr}
;;;215    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;216    	LPC_GPIO_TypeDef *pGPIO = GPIO_GetPointer(portNum);
000006  4630              MOV      r0,r6
000008  f7fffffe          BL       GPIO_GetPointer
00000c  4605              MOV      r5,r0
;;;217    
;;;218    	if (pGPIO != NULL) {
00000e  b105              CBZ      r5,|L28.18|
;;;219    		pGPIO->FIOSET = bitValue;
000010  61ac              STR      r4,[r5,#0x18]
                  |L28.18|
;;;220    	}
;;;221    }
000012  bd70              POP      {r4-r6,pc}
;;;222    
                          ENDP


;*** Start embedded assembler ***

#line 1 "Lib\\Drivers\\source\\lpc17xx_gpio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_lpc17xx_gpio_c_38c397c6____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___14_lpc17xx_gpio_c_38c397c6____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_lpc17xx_gpio_c_38c397c6____REVSH|
#line 144
|__asm___14_lpc17xx_gpio_c_38c397c6____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
