; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\lpc17xx_emac.o --asm_dir=.\Flash\ --list_dir=.\Flash\ --depend=.\flash\lpc17xx_emac.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\Lib\Drivers\include -I.\Inc -I.\Lib\Usb_Drivers\Inc -I.\Lib\CLib__1_0_0_4\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\NXP\LPC17xx -D__UVISION_VERSION=525 --omf_browse=.\flash\lpc17xx_emac.crf Lib\Drivers\source\lpc17xx_emac.c]
                          THUMB

                          AREA ||i.EMAC_CheckPHYStatus||, CODE, READONLY, ALIGN=1

                  EMAC_CheckPHYStatus PROC
;;;425     **********************************************************************/
;;;426    int32_t EMAC_CheckPHYStatus(uint32_t ulPHYState)
000000  b570              PUSH     {r4-r6,lr}
;;;427    {
000002  4606              MOV      r6,r0
;;;428    	int32_t regv, tmp;
;;;429    #ifdef MCB_LPC_1768
;;;430    	regv = read_PHY (EMAC_PHY_REG_STS);
000004  2010              MOVS     r0,#0x10
000006  f7fffffe          BL       read_PHY
00000a  4605              MOV      r5,r0
;;;431    	switch(ulPHYState){
00000c  b126              CBZ      r6,|L1.24|
00000e  2e01              CMP      r6,#1
000010  d005              BEQ      |L1.30|
000012  2e02              CMP      r6,#2
000014  d10f              BNE      |L1.54|
000016  e006              B        |L1.38|
                  |L1.24|
;;;432    	case EMAC_PHY_STAT_LINK:
;;;433    		tmp = (regv & EMAC_PHY_SR_LINK) ? 1 : 0;
000018  f0050401          AND      r4,r5,#1
;;;434    		break;
00001c  e00e              B        |L1.60|
                  |L1.30|
;;;435    	case EMAC_PHY_STAT_SPEED:
;;;436    		tmp = (regv & EMAC_PHY_SR_SPEED) ? 0 : 1;
00001e  2001              MOVS     r0,#1
000020  ea200455          BIC      r4,r0,r5,LSR #1
;;;437    		break;
000024  e00a              B        |L1.60|
                  |L1.38|
;;;438    	case EMAC_PHY_STAT_DUP:
;;;439    		tmp = (regv & EMAC_PHY_SR_FULL_DUP) ? 1 : 0;
000026  f40540a0          AND      r0,r5,#0x5000
00002a  b108              CBZ      r0,|L1.48|
00002c  2001              MOVS     r0,#1
00002e  e000              B        |L1.50|
                  |L1.48|
000030  2000              MOVS     r0,#0
                  |L1.50|
000032  4604              MOV      r4,r0
;;;440    		break;
000034  e002              B        |L1.60|
                  |L1.54|
;;;441    #elif defined(IAR_LPC_1768)
;;;442    	/* Use IAR_LPC_1768 board:
;;;443    	 * FSZ8721BL doesn't have Status Register
;;;444    	 * so we read Basic Mode Status Register (0x01h) instead
;;;445    	 */
;;;446    	regv = read_PHY (EMAC_PHY_REG_BMSR);
;;;447    	switch(ulPHYState){
;;;448    	case EMAC_PHY_STAT_LINK:
;;;449    		tmp = (regv & EMAC_PHY_BMSR_LINK_STATUS) ? 1 : 0;
;;;450    		break;
;;;451    	case EMAC_PHY_STAT_SPEED:
;;;452    		tmp = (regv & EMAC_PHY_SR_100_SPEED) ? 1 : 0;
;;;453    		break;
;;;454    	case EMAC_PHY_STAT_DUP:
;;;455    		tmp = (regv & EMAC_PHY_SR_FULL_DUP) ? 1 : 0;
;;;456    		break;
;;;457    #endif
;;;458    	default:
;;;459    		tmp = -1;
000036  f04f34ff          MOV      r4,#0xffffffff
;;;460    		break;
00003a  bf00              NOP      
                  |L1.60|
00003c  bf00              NOP                            ;434
;;;461    	}
;;;462    	return (tmp);
00003e  4620              MOV      r0,r4
;;;463    }
000040  bd70              POP      {r4-r6,pc}
;;;464    
                          ENDP


                          AREA ||i.EMAC_CheckReceiveDataStatus||, CODE, READONLY, ALIGN=2

                  EMAC_CheckReceiveDataStatus PROC
;;;896     **********************************************************************/
;;;897    FlagStatus EMAC_CheckReceiveDataStatus(uint32_t ulRxStatType)
000000  4601              MOV      r1,r0
;;;898    {
;;;899    	uint32_t idx;
;;;900    	idx = LPC_EMAC->RxConsumeIndex;
000002  4805              LDR      r0,|L2.24|
000004  6802              LDR      r2,[r0,#0]
;;;901    	return (((Rx_Stat[idx].Info) & ulRxStatType) ? SET : RESET);
000006  4805              LDR      r0,|L2.28|
000008  f8500032          LDR      r0,[r0,r2,LSL #3]
00000c  4008              ANDS     r0,r0,r1
00000e  b108              CBZ      r0,|L2.20|
000010  2001              MOVS     r0,#1
                  |L2.18|
;;;902    }
000012  4770              BX       lr
                  |L2.20|
000014  2000              MOVS     r0,#0                 ;901
000016  e7fc              B        |L2.18|
;;;903    
                          ENDP

                  |L2.24|
                          DCD      0x50000118
                  |L2.28|
                          DCD      Rx_Stat

                          AREA ||i.EMAC_CheckReceiveIndex||, CODE, READONLY, ALIGN=2

                  EMAC_CheckReceiveIndex PROC
;;;838     **********************************************************************/
;;;839    Bool EMAC_CheckReceiveIndex(void)
000000  4805              LDR      r0,|L3.24|
;;;840    {
;;;841    	if (LPC_EMAC->RxConsumeIndex != LPC_EMAC->RxProduceIndex) {
000002  6800              LDR      r0,[r0,#0]
000004  f04f41a0          MOV      r1,#0x50000000
000008  f8d11114          LDR      r1,[r1,#0x114]
00000c  4288              CMP      r0,r1
00000e  d001              BEQ      |L3.20|
;;;842    		return TRUE;
000010  2001              MOVS     r0,#1
                  |L3.18|
;;;843    	} else {
;;;844    		return FALSE;
;;;845    	}
;;;846    }
000012  4770              BX       lr
                  |L3.20|
000014  2000              MOVS     r0,#0                 ;844
000016  e7fc              B        |L3.18|
;;;847    
                          ENDP

                  |L3.24|
                          DCD      0x50000118

                          AREA ||i.EMAC_CheckTransmitIndex||, CODE, READONLY, ALIGN=2

                  EMAC_CheckTransmitIndex PROC
;;;858     **********************************************************************/
;;;859    Bool EMAC_CheckTransmitIndex(void)
000000  480a              LDR      r0,|L4.44|
;;;860    {
;;;861        uint32_t tmp = LPC_EMAC->TxConsumeIndex;
000002  6801              LDR      r1,[r0,#0]
;;;862        if (LPC_EMAC->TxProduceIndex == ( tmp - 1 ))
000004  f04f40a0          MOV      r0,#0x50000000
000008  f8d02128          LDR      r2,[r0,#0x128]
00000c  1e48              SUBS     r0,r1,#1
00000e  4282              CMP      r2,r0
000010  d101              BNE      |L4.22|
;;;863        {
;;;864            return FALSE;
000012  2000              MOVS     r0,#0
                  |L4.20|
;;;865        }
;;;866        else if( ( tmp == 0 ) && ( LPC_EMAC->TxProduceIndex == ( EMAC_NUM_TX_FRAG - 1 ) ) )
;;;867        {
;;;868            return FALSE;
;;;869        }
;;;870        else
;;;871        {
;;;872            return TRUE;
;;;873        }
;;;874    }
000014  4770              BX       lr
                  |L4.22|
000016  b931              CBNZ     r1,|L4.38|
000018  4804              LDR      r0,|L4.44|
00001a  1f00              SUBS     r0,r0,#4              ;866
00001c  6800              LDR      r0,[r0,#0]            ;866
00001e  2802              CMP      r0,#2                 ;866
000020  d101              BNE      |L4.38|
000022  2000              MOVS     r0,#0                 ;868
000024  e7f6              B        |L4.20|
                  |L4.38|
000026  2001              MOVS     r0,#1                 ;872
000028  e7f4              B        |L4.20|
;;;875    
                          ENDP

00002a  0000              DCW      0x0000
                  |L4.44|
                          DCD      0x5000012c

                          AREA ||i.EMAC_DeInit||, CODE, READONLY, ALIGN=2

                  EMAC_DeInit PROC
;;;393     **********************************************************************/
;;;394    void EMAC_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;395    {
;;;396    	// Disable all interrupt
;;;397    	LPC_EMAC->IntEnable = 0x00;
000002  2000              MOVS     r0,#0
000004  4905              LDR      r1,|L5.28|
000006  6008              STR      r0,[r1,#0]
;;;398    	// Clear all pending interrupt
;;;399    	LPC_EMAC->IntClear = (0xFF) | (EMAC_INT_SOFT_INT | EMAC_INT_WAKEUP);
000008  f24300ff          MOV      r0,#0x30ff
00000c  1d09              ADDS     r1,r1,#4
00000e  6008              STR      r0,[r1,#0]
;;;400    
;;;401    	/* TurnOff clock and power for Ethernet module */
;;;402    	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCENET, DISABLE);
000010  2100              MOVS     r1,#0
000012  f04f4080          MOV      r0,#0x40000000
000016  f7fffffe          BL       CLKPWR_ConfigPPWR
;;;403    }
00001a  bd10              POP      {r4,pc}
;;;404    
                          ENDP

                  |L5.28|
                          DCD      0x50000fe4

                          AREA ||i.EMAC_GetReceiveDataSize||, CODE, READONLY, ALIGN=2

                  EMAC_GetReceiveDataSize PROC
;;;910     **********************************************************************/
;;;911    uint32_t EMAC_GetReceiveDataSize(void)
000000  4803              LDR      r0,|L6.16|
;;;912    {
;;;913    	uint32_t idx;
;;;914    	idx =LPC_EMAC->RxConsumeIndex;
000002  6801              LDR      r1,[r0,#0]
;;;915    	return ((Rx_Stat[idx].Info) & EMAC_RINFO_SIZE);
000004  4803              LDR      r0,|L6.20|
000006  f8300031          LDRH     r0,[r0,r1,LSL #3]
00000a  f3c0000a          UBFX     r0,r0,#0,#11
;;;916    }
00000e  4770              BX       lr
;;;917    
                          ENDP

                  |L6.16|
                          DCD      0x50000118
                  |L6.20|
                          DCD      Rx_Stat

                          AREA ||i.EMAC_GetWoLStatus||, CODE, READONLY, ALIGN=2

                  EMAC_GetWoLStatus PROC
;;;715     **********************************************************************/
;;;716    FlagStatus EMAC_GetWoLStatus(uint32_t ulWoLMode)
000000  4601              MOV      r1,r0
;;;717    {
;;;718    	if (LPC_EMAC->RxFilterWoLStatus & ulWoLMode) {
000002  4805              LDR      r0,|L7.24|
000004  6800              LDR      r0,[r0,#0]
000006  4008              ANDS     r0,r0,r1
000008  b120              CBZ      r0,|L7.20|
;;;719    		LPC_EMAC->RxFilterWoLClear = ulWoLMode;
00000a  4803              LDR      r0,|L7.24|
00000c  1d00              ADDS     r0,r0,#4
00000e  6001              STR      r1,[r0,#0]
;;;720    		return SET;
000010  2001              MOVS     r0,#1
                  |L7.18|
;;;721    	} else {
;;;722    		return RESET;
;;;723    	}
;;;724    }
000012  4770              BX       lr
                  |L7.20|
000014  2000              MOVS     r0,#0                 ;722
000016  e7fc              B        |L7.18|
;;;725    
                          ENDP

                  |L7.24|
                          DCD      0x50000204

                          AREA ||i.EMAC_Init||, CODE, READONLY, ALIGN=2

                  EMAC_Init PROC
;;;297     **********************************************************************/
;;;298    Status EMAC_Init(EMAC_CFG_Type *EMAC_ConfigStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;299    {
000004  4605              MOV      r5,r0
;;;300    	/* Initialize the EMAC Ethernet controller. */
;;;301    	int32_t regv,tout, tmp;
;;;302    
;;;303    	/* Set up clock and power for Ethernet module */
;;;304    	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCENET, ENABLE);
000006  2101              MOVS     r1,#1
000008  0788              LSLS     r0,r1,#30
00000a  f7fffffe          BL       CLKPWR_ConfigPPWR
;;;305    
;;;306    	/* Reset all EMAC internal modules */
;;;307    	LPC_EMAC->MAC1    = EMAC_MAC1_RES_TX | EMAC_MAC1_RES_MCS_TX | EMAC_MAC1_RES_RX |
00000e  f44f404f          MOV      r0,#0xcf00
000012  f04f41a0          MOV      r1,#0x50000000
000016  6008              STR      r0,[r1,#0]
;;;308    					EMAC_MAC1_RES_MCS_RX | EMAC_MAC1_SIM_RES | EMAC_MAC1_SOFT_RES;
;;;309    
;;;310    	LPC_EMAC->Command = EMAC_CR_REG_RES | EMAC_CR_TX_RES | EMAC_CR_RX_RES | EMAC_CR_PASS_RUNT_FRM;
000018  2078              MOVS     r0,#0x78
00001a  493f              LDR      r1,|L8.280|
00001c  6008              STR      r0,[r1,#0]
;;;311    
;;;312    	/* A short delay after reset. */
;;;313    	for (tout = 100; tout; tout--);
00001e  2464              MOVS     r4,#0x64
000020  e000              B        |L8.36|
                  |L8.34|
000022  1e64              SUBS     r4,r4,#1
                  |L8.36|
000024  2c00              CMP      r4,#0
000026  d1fc              BNE      |L8.34|
;;;314    
;;;315    	/* Initialize MAC control registers. */
;;;316    	LPC_EMAC->MAC1 = EMAC_MAC1_PASS_ALL;
000028  2002              MOVS     r0,#2
00002a  f04f41a0          MOV      r1,#0x50000000
00002e  6008              STR      r0,[r1,#0]
;;;317    	LPC_EMAC->MAC2 = EMAC_MAC2_CRC_EN | EMAC_MAC2_PAD_EN;
000030  2030              MOVS     r0,#0x30
000032  6048              STR      r0,[r1,#4]
;;;318    	LPC_EMAC->MAXF = EMAC_ETH_MAX_FLEN;
000034  0140              LSLS     r0,r0,#5
000036  6148              STR      r0,[r1,#0x14]
;;;319    	/*
;;;320    	 * Find the clock that close to desired target clock
;;;321    	 */
;;;322    	tmp = SystemCoreClock / EMAC_MCFG_MII_MAXCLK;
000038  4838              LDR      r0,|L8.284|
00003a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00003c  4938              LDR      r1,|L8.288|
00003e  fbb0f7f1          UDIV     r7,r0,r1
;;;323    	for (tout = 0; tout < sizeof (EMAC_clkdiv); tout++){
000042  bf00              NOP      
000044  e005              B        |L8.82|
                  |L8.70|
;;;324    		if (EMAC_clkdiv[tout] >= tmp) break;
000046  4837              LDR      r0,|L8.292|
000048  5d00              LDRB     r0,[r0,r4]
00004a  42b8              CMP      r0,r7
00004c  db00              BLT      |L8.80|
00004e  e002              B        |L8.86|
                  |L8.80|
000050  1c64              ADDS     r4,r4,#1              ;323
                  |L8.82|
000052  2c0f              CMP      r4,#0xf               ;323
000054  d3f7              BCC      |L8.70|
                  |L8.86|
000056  bf00              NOP      
;;;325    	}
;;;326    	tout++;
000058  1c64              ADDS     r4,r4,#1
;;;327    	// Write to MAC configuration register and reset
;;;328    	LPC_EMAC->MCFG = EMAC_MCFG_CLK_SEL(tout) | EMAC_MCFG_RES_MII;
00005a  f004000f          AND      r0,r4,#0xf
00005e  f44f4100          MOV      r1,#0x8000
000062  ea410080          ORR      r0,r1,r0,LSL #2
000066  f04f41a0          MOV      r1,#0x50000000
00006a  6208              STR      r0,[r1,#0x20]
;;;329    	// release reset
;;;330    	LPC_EMAC->MCFG &= ~(EMAC_MCFG_RES_MII);
00006c  4608              MOV      r0,r1
00006e  6a00              LDR      r0,[r0,#0x20]
000070  f4204000          BIC      r0,r0,#0x8000
000074  6208              STR      r0,[r1,#0x20]
;;;331    	LPC_EMAC->CLRT = EMAC_CLRT_DEF;
000076  f243700f          MOV      r0,#0x370f
00007a  6108              STR      r0,[r1,#0x10]
;;;332    	LPC_EMAC->IPGR = EMAC_IPGR_P2_DEF;
00007c  2012              MOVS     r0,#0x12
00007e  60c8              STR      r0,[r1,#0xc]
;;;333    
;;;334    	/* Enable Reduced MII interface. */
;;;335    	LPC_EMAC->Command = EMAC_CR_RMII | EMAC_CR_PASS_RUNT_FRM;
000080  0140              LSLS     r0,r0,#5
000082  4925              LDR      r1,|L8.280|
000084  6008              STR      r0,[r1,#0]
;;;336    
;;;337    	/* Reset Reduced MII Logic. */
;;;338    //	LPC_EMAC->SUPP = EMAC_SUPP_RES_RMII;
;;;339    
;;;340    	for (tout = 100; tout; tout--);
000086  2464              MOVS     r4,#0x64
000088  e000              B        |L8.140|
                  |L8.138|
00008a  1e64              SUBS     r4,r4,#1
                  |L8.140|
00008c  2c00              CMP      r4,#0
00008e  d1fc              BNE      |L8.138|
;;;341    	LPC_EMAC->SUPP = 0;
000090  2000              MOVS     r0,#0
000092  f04f41a0          MOV      r1,#0x50000000
000096  6188              STR      r0,[r1,#0x18]
;;;342    
;;;343    	/* Put the DP83848C in reset mode */
;;;344    	write_PHY (EMAC_PHY_REG_BMCR, EMAC_PHY_BMCR_RESET);
000098  f44f4100          MOV      r1,#0x8000
00009c  f7fffffe          BL       write_PHY
;;;345    
;;;346    	/* Wait for hardware reset to end. */
;;;347    	for (tout = EMAC_PHY_RESP_TOUT; tout>=0; tout--) {
0000a0  f44f1480          MOV      r4,#0x100000
0000a4  e00c              B        |L8.192|
                  |L8.166|
;;;348    		regv = read_PHY (EMAC_PHY_REG_BMCR);
0000a6  2000              MOVS     r0,#0
0000a8  f7fffffe          BL       read_PHY
0000ac  4606              MOV      r6,r0
;;;349    		if (!(regv & (EMAC_PHY_BMCR_RESET | EMAC_PHY_BMCR_POWERDOWN))) {
0000ae  f4064008          AND      r0,r6,#0x8800
0000b2  b900              CBNZ     r0,|L8.182|
;;;350    			/* Reset complete, device not Power Down. */
;;;351    			break;
0000b4  e006              B        |L8.196|
                  |L8.182|
;;;352    		}
;;;353    		if (tout == 0){
0000b6  b914              CBNZ     r4,|L8.190|
;;;354    			// Time out, return ERROR
;;;355    			return (ERROR);
0000b8  2000              MOVS     r0,#0
                  |L8.186|
;;;356    		}
;;;357    	}
;;;358    
;;;359    	// Set PHY mode
;;;360    	if (EMAC_SetPHYMode(EMAC_ConfigStruct->Mode) < 0){
;;;361    		return (ERROR);
;;;362    	}
;;;363    
;;;364    	// Set EMAC address
;;;365    	setEmacAddr(EMAC_ConfigStruct->pbEMAC_Addr);
;;;366    
;;;367    	/* Initialize Tx and Rx DMA Descriptors */
;;;368    	rx_descr_init ();
;;;369    	tx_descr_init ();
;;;370    
;;;371    	// Set Receive Filter register: enable broadcast and multicast
;;;372    	LPC_EMAC->RxFilterCtrl = EMAC_RFC_MCAST_EN | EMAC_RFC_BCAST_EN | EMAC_RFC_PERFECT_EN;
;;;373    
;;;374    	/* Enable Rx Done and Tx Done interrupt for EMAC */
;;;375    	LPC_EMAC->IntEnable = EMAC_INT_RX_DONE | EMAC_INT_TX_DONE;
;;;376    
;;;377    	/* Reset all interrupts */
;;;378    	LPC_EMAC->IntClear  = 0xFFFF;
;;;379    
;;;380    	/* Enable receive and transmit mode of MAC Ethernet core */
;;;381    	LPC_EMAC->Command  |= (EMAC_CR_RX_EN | EMAC_CR_TX_EN);
;;;382    	LPC_EMAC->MAC1     |= EMAC_MAC1_REC_EN;
;;;383    
;;;384    	return SUCCESS;
;;;385    }
0000ba  e8bd81f0          POP      {r4-r8,pc}
                  |L8.190|
0000be  1e64              SUBS     r4,r4,#1              ;347
                  |L8.192|
0000c0  2c00              CMP      r4,#0                 ;347
0000c2  daf0              BGE      |L8.166|
                  |L8.196|
0000c4  bf00              NOP                            ;351
0000c6  6828              LDR      r0,[r5,#0]            ;360
0000c8  f7fffffe          BL       EMAC_SetPHYMode
0000cc  2800              CMP      r0,#0                 ;360
0000ce  da01              BGE      |L8.212|
0000d0  2000              MOVS     r0,#0                 ;361
0000d2  e7f2              B        |L8.186|
                  |L8.212|
0000d4  6868              LDR      r0,[r5,#4]            ;365
0000d6  f7fffffe          BL       setEmacAddr
0000da  f7fffffe          BL       rx_descr_init
0000de  f7fffffe          BL       tx_descr_init
0000e2  2026              MOVS     r0,#0x26              ;372
0000e4  4910              LDR      r1,|L8.296|
0000e6  6008              STR      r0,[r1,#0]            ;372
0000e8  2088              MOVS     r0,#0x88              ;375
0000ea  4910              LDR      r1,|L8.300|
0000ec  6008              STR      r0,[r1,#0]            ;375
0000ee  f64f70ff          MOV      r0,#0xffff            ;378
0000f2  1d09              ADDS     r1,r1,#4              ;378
0000f4  6008              STR      r0,[r1,#0]            ;378
0000f6  f04f40a0          MOV      r0,#0x50000000        ;381
0000fa  f8d00100          LDR      r0,[r0,#0x100]        ;381
0000fe  f0400003          ORR      r0,r0,#3              ;381
000102  f04f41a0          MOV      r1,#0x50000000        ;381
000106  f8c10100          STR      r0,[r1,#0x100]        ;381
00010a  4608              MOV      r0,r1                 ;382
00010c  6800              LDR      r0,[r0,#0]            ;382
00010e  f0400001          ORR      r0,r0,#1              ;382
000112  6008              STR      r0,[r1,#0]            ;382
000114  2001              MOVS     r0,#1                 ;384
000116  e7d0              B        |L8.186|
;;;386    
                          ENDP

                  |L8.280|
                          DCD      0x50000100
                  |L8.284|
                          DCD      SystemCoreClock
                  |L8.288|
                          DCD      0x002625a0
                  |L8.292|
                          DCD      EMAC_clkdiv
                  |L8.296|
                          DCD      0x50000200
                  |L8.300|
                          DCD      0x50000fe4

                          AREA ||i.EMAC_IntCmd||, CODE, READONLY, ALIGN=2

                  EMAC_IntCmd PROC
;;;791     **********************************************************************/
;;;792    void EMAC_IntCmd(uint32_t ulIntType, FunctionalState NewState)
000000  2901              CMP      r1,#1
;;;793    {
;;;794    	if (NewState == ENABLE) {
000002  d105              BNE      |L9.16|
;;;795    		LPC_EMAC->IntEnable |= ulIntType;
000004  4a05              LDR      r2,|L9.28|
000006  6812              LDR      r2,[r2,#0]
000008  4302              ORRS     r2,r2,r0
00000a  4b04              LDR      r3,|L9.28|
00000c  601a              STR      r2,[r3,#0]
00000e  e004              B        |L9.26|
                  |L9.16|
;;;796    	} else {
;;;797    		LPC_EMAC->IntEnable &= ~(ulIntType);
000010  4a02              LDR      r2,|L9.28|
000012  6812              LDR      r2,[r2,#0]
000014  4382              BICS     r2,r2,r0
000016  4b01              LDR      r3,|L9.28|
000018  601a              STR      r2,[r3,#0]
                  |L9.26|
;;;798    	}
;;;799    }
00001a  4770              BX       lr
;;;800    
                          ENDP

                  |L9.28|
                          DCD      0x50000fe4

                          AREA ||i.EMAC_IntGetStatus||, CODE, READONLY, ALIGN=2

                  EMAC_IntGetStatus PROC
;;;817     **********************************************************************/
;;;818    IntStatus EMAC_IntGetStatus(uint32_t ulIntType)
000000  4601              MOV      r1,r0
;;;819    {
;;;820    	if (LPC_EMAC->IntStatus & ulIntType) {
000002  4805              LDR      r0,|L10.24|
000004  6800              LDR      r0,[r0,#0]
000006  4008              ANDS     r0,r0,r1
000008  b120              CBZ      r0,|L10.20|
;;;821    		LPC_EMAC->IntClear = ulIntType;
00000a  4803              LDR      r0,|L10.24|
00000c  3008              ADDS     r0,r0,#8
00000e  6001              STR      r1,[r0,#0]
;;;822    		return SET;
000010  2001              MOVS     r0,#1
                  |L10.18|
;;;823    	} else {
;;;824    		return RESET;
;;;825    	}
;;;826    }
000012  4770              BX       lr
                  |L10.20|
000014  2000              MOVS     r0,#0                 ;824
000016  e7fc              B        |L10.18|
;;;827    
                          ENDP

                  |L10.24|
                          DCD      0x50000fe0

                          AREA ||i.EMAC_ReadPacketBuffer||, CODE, READONLY, ALIGN=2

                  EMAC_ReadPacketBuffer PROC
;;;757     **********************************************************************/
;;;758    void EMAC_ReadPacketBuffer(EMAC_PACKETBUF_Type *pDataStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;759    {
;;;760    	uint32_t idx, len;
;;;761    	uint32_t *dp, *sp;
;;;762    
;;;763    	idx = LPC_EMAC->RxConsumeIndex;
000002  4d09              LDR      r5,|L11.40|
000004  682c              LDR      r4,[r5,#0]
;;;764    	dp = (uint32_t *)pDataStruct->pbDataBuf;
000006  6842              LDR      r2,[r0,#4]
;;;765    	sp = (uint32_t *)Rx_Desc[idx].Packet;
000008  4d08              LDR      r5,|L11.44|
00000a  f8553034          LDR      r3,[r5,r4,LSL #3]
;;;766    
;;;767    	if (pDataStruct->pbDataBuf != NULL) {
00000e  6845              LDR      r5,[r0,#4]
000010  b145              CBZ      r5,|L11.36|
;;;768    		for (len = (pDataStruct->ulDataLen + 3) >> 2; len; len--) {
000012  6805              LDR      r5,[r0,#0]
000014  1ced              ADDS     r5,r5,#3
000016  08a9              LSRS     r1,r5,#2
000018  e002              B        |L11.32|
                  |L11.26|
;;;769    			*dp++ = *sp++;
00001a  cb20              LDM      r3!,{r5}
00001c  c220              STM      r2!,{r5}
00001e  1e49              SUBS     r1,r1,#1              ;768
                  |L11.32|
000020  2900              CMP      r1,#0                 ;768
000022  d1fa              BNE      |L11.26|
                  |L11.36|
;;;770    		}
;;;771    	}
;;;772    }
000024  bd30              POP      {r4,r5,pc}
;;;773    
                          ENDP

000026  0000              DCW      0x0000
                  |L11.40|
                          DCD      0x50000118
                  |L11.44|
                          DCD      Rx_Desc

                          AREA ||i.EMAC_SetFilterMode||, CODE, READONLY, ALIGN=2

                  EMAC_SetFilterMode PROC
;;;689     **********************************************************************/
;;;690    void EMAC_SetFilterMode(uint32_t ulFilterMode, FunctionalState NewState)
000000  2901              CMP      r1,#1
;;;691    {
;;;692    	if (NewState == ENABLE){
000002  d107              BNE      |L12.20|
;;;693    		LPC_EMAC->RxFilterCtrl |= ulFilterMode;
000004  4a07              LDR      r2,|L12.36|
000006  6812              LDR      r2,[r2,#0]
000008  4302              ORRS     r2,r2,r0
00000a  f04f43a0          MOV      r3,#0x50000000
00000e  f8c32200          STR      r2,[r3,#0x200]
000012  e006              B        |L12.34|
                  |L12.20|
;;;694    	} else {
;;;695    		LPC_EMAC->RxFilterCtrl &= ~ulFilterMode;
000014  4a03              LDR      r2,|L12.36|
000016  6812              LDR      r2,[r2,#0]
000018  4382              BICS     r2,r2,r0
00001a  f04f43a0          MOV      r3,#0x50000000
00001e  f8c32200          STR      r2,[r3,#0x200]
                  |L12.34|
;;;696    	}
;;;697    }
000022  4770              BX       lr
;;;698    
                          ENDP

                  |L12.36|
                          DCD      0x50000200

                          AREA ||i.EMAC_SetHashFilter||, CODE, READONLY, ALIGN=2

                  EMAC_SetHashFilter PROC
;;;639     **********************************************************************/
;;;640    void EMAC_SetHashFilter(uint8_t dstMAC_addr[], FunctionalState NewState)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;641    {
000004  4680              MOV      r8,r0
000006  460e              MOV      r6,r1
;;;642    	uint32_t *pReg;
;;;643    	uint32_t tmp;
;;;644    	int32_t crc;
;;;645    
;;;646    	// Calculate the CRC from the destination MAC address
;;;647    	crc = emac_CRCCalc(dstMAC_addr, 6);
000008  2106              MOVS     r1,#6
00000a  4640              MOV      r0,r8
00000c  f7fffffe          BL       emac_CRCCalc
000010  4605              MOV      r5,r0
;;;648    	// Extract the value from CRC to get index value for hash filter table
;;;649    	crc = (crc >> 23) & 0x3F;
000012  f3c555c5          UBFX     r5,r5,#23,#6
;;;650    
;;;651    	pReg = (crc > 31) ? ((uint32_t *)&LPC_EMAC->HashFilterH) \
000016  2d1f              CMP      r5,#0x1f
000018  dd01              BLE      |L13.30|
00001a  4811              LDR      r0,|L13.96|
00001c  e001              B        |L13.34|
                  |L13.30|
;;;652    								: ((uint32_t *)&LPC_EMAC->HashFilterL);
00001e  4810              LDR      r0,|L13.96|
000020  1f00              SUBS     r0,r0,#4
                  |L13.34|
000022  4604              MOV      r4,r0
;;;653    	tmp = (crc > 31) ? (crc - 32) : crc;
000024  2d1f              CMP      r5,#0x1f
000026  dd02              BLE      |L13.46|
000028  f1a50020          SUB      r0,r5,#0x20
00002c  e000              B        |L13.48|
                  |L13.46|
00002e  4628              MOV      r0,r5
                  |L13.48|
000030  4607              MOV      r7,r0
;;;654    	if (NewState == ENABLE) {
000032  2e01              CMP      r6,#1
000034  d105              BNE      |L13.66|
;;;655    		(*pReg) |= (1UL << tmp);
000036  2101              MOVS     r1,#1
000038  40b9              LSLS     r1,r1,r7
00003a  6820              LDR      r0,[r4,#0]
00003c  4308              ORRS     r0,r0,r1
00003e  6020              STR      r0,[r4,#0]
000040  e004              B        |L13.76|
                  |L13.66|
;;;656    	} else {
;;;657    		(*pReg) &= ~(1UL << tmp);
000042  2101              MOVS     r1,#1
000044  40b9              LSLS     r1,r1,r7
000046  6820              LDR      r0,[r4,#0]
000048  4388              BICS     r0,r0,r1
00004a  6020              STR      r0,[r4,#0]
                  |L13.76|
;;;658    	}
;;;659    	// Enable Rx Filter
;;;660    	LPC_EMAC->Command &= ~EMAC_CR_PASS_RX_FILT;
00004c  4805              LDR      r0,|L13.100|
00004e  6800              LDR      r0,[r0,#0]
000050  f0200080          BIC      r0,r0,#0x80
000054  f04f41a0          MOV      r1,#0x50000000
000058  f8c10100          STR      r0,[r1,#0x100]
;;;661    }
00005c  e8bd81f0          POP      {r4-r8,pc}
;;;662    
                          ENDP

                  |L13.96|
                          DCD      0x50000214
                  |L13.100|
                          DCD      0x50000100

                          AREA ||i.EMAC_SetPHYMode||, CODE, READONLY, ALIGN=2

                  EMAC_SetPHYMode PROC
;;;475     **********************************************************************/
;;;476    int32_t EMAC_SetPHYMode(uint32_t ulPHYMode)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;477    {
000004  4604              MOV      r4,r0
;;;478    	int32_t id1, id2, tout;
;;;479    
;;;480    	/* Check if this is a DP83848C PHY. */
;;;481    	id1 = read_PHY (EMAC_PHY_REG_IDR1);
000006  2002              MOVS     r0,#2
000008  f7fffffe          BL       read_PHY
00000c  4606              MOV      r6,r0
;;;482    	id2 = read_PHY (EMAC_PHY_REG_IDR2);
00000e  2003              MOVS     r0,#3
000010  f7fffffe          BL       read_PHY
000014  4607              MOV      r7,r0
;;;483    
;;;484    #ifdef MCB_LPC_1768
;;;485    	if (((id1 << 16) | (id2 & 0xFFF0)) == EMAC_DP83848C_ID) {
000016  f64f70f0          MOV      r0,#0xfff0
00001a  4038              ANDS     r0,r0,r7
00001c  ea404006          ORR      r0,r0,r6,LSL #16
000020  491e              LDR      r1,|L14.156|
000022  4288              CMP      r0,r1
000024  d12e              BNE      |L14.132|
;;;486    		switch(ulPHYMode){
000026  2c05              CMP      r4,#5
000028  d227              BCS      |L14.122|
00002a  e8dff004          TBB      [pc,r4]
00002e  030f              DCB      0x03,0x0f
000030  151a2000          DCB      0x15,0x1a,0x20,0x00
;;;487    		case EMAC_MODE_AUTO:
;;;488    			write_PHY (EMAC_PHY_REG_BMCR, EMAC_PHY_AUTO_NEG);
000034  f44f5140          MOV      r1,#0x3000
000038  2000              MOVS     r0,#0
00003a  f7fffffe          BL       write_PHY
;;;489    #elif defined(IAR_LPC_1768) /* Use IAR LPC1768 KickStart board */
;;;490    	if (((id1 << 16) | id2) == EMAC_KSZ8721BL_ID) {
;;;491    		/* Configure the PHY device */
;;;492    		switch(ulPHYMode){
;;;493    		case EMAC_MODE_AUTO:
;;;494    			/* Use auto-negotiation about the link speed. */
;;;495    			write_PHY (EMAC_PHY_REG_BMCR, EMAC_PHY_AUTO_NEG);
;;;496    //			write_PHY (EMAC_PHY_REG_BMCR, EMAC_PHY_BMCR_AN);
;;;497    #endif
;;;498    			/* Wait to complete Auto_Negotiation */
;;;499    			for (tout = EMAC_PHY_RESP_TOUT; tout>=0; tout--) {
00003e  f44f1580          MOV      r5,#0x100000
000042  e000              B        |L14.70|
                  |L14.68|
000044  1e6d              SUBS     r5,r5,#1
                  |L14.70|
000046  2d00              CMP      r5,#0
000048  dafc              BGE      |L14.68|
;;;500    				
;;;501    			}
;;;502    			break;
00004a  e01a              B        |L14.130|
;;;503    		case EMAC_MODE_10M_FULL:
;;;504    			/* Connect at 10MBit full-duplex */
;;;505    			write_PHY (EMAC_PHY_REG_BMCR, EMAC_PHY_FULLD_10M);
00004c  f44f7180          MOV      r1,#0x100
000050  2000              MOVS     r0,#0
000052  f7fffffe          BL       write_PHY
;;;506    			break;
000056  e014              B        |L14.130|
;;;507    		case EMAC_MODE_10M_HALF:
;;;508    			/* Connect at 10MBit half-duplex */
;;;509    			write_PHY (EMAC_PHY_REG_BMCR, EMAC_PHY_HALFD_10M);
000058  2100              MOVS     r1,#0
00005a  4608              MOV      r0,r1
00005c  f7fffffe          BL       write_PHY
;;;510    			break;
000060  e00f              B        |L14.130|
;;;511    		case EMAC_MODE_100M_FULL:
;;;512    			/* Connect at 100MBit full-duplex */
;;;513    			write_PHY (EMAC_PHY_REG_BMCR, EMAC_PHY_FULLD_100M);
000062  f44f5104          MOV      r1,#0x2100
000066  2000              MOVS     r0,#0
000068  f7fffffe          BL       write_PHY
;;;514    			break;
00006c  e009              B        |L14.130|
;;;515    		case EMAC_MODE_100M_HALF:
;;;516    			/* Connect at 100MBit half-duplex */
;;;517    			write_PHY (EMAC_PHY_REG_BMCR, EMAC_PHY_HALFD_100M);
00006e  f44f5100          MOV      r1,#0x2000
000072  2000              MOVS     r0,#0
000074  f7fffffe          BL       write_PHY
;;;518    			break;
000078  e003              B        |L14.130|
                  |L14.122|
;;;519    		default:
;;;520    			// un-supported
;;;521    			return (-1);
00007a  f04f30ff          MOV      r0,#0xffffffff
                  |L14.126|
;;;522    		}
;;;523    	}
;;;524    	// It's not correct module ID
;;;525    	else {
;;;526    		return (-1);
;;;527    	}
;;;528    
;;;529    	// Update EMAC configuration with current PHY status
;;;530    	if (EMAC_UpdatePHYStatus() < 0){
;;;531    		return (-1);
;;;532    	}
;;;533    
;;;534    	// Complete
;;;535    	return (0);
;;;536    }
00007e  e8bd81f0          POP      {r4-r8,pc}
                  |L14.130|
000082  e002              B        |L14.138|
                  |L14.132|
000084  f04f30ff          MOV      r0,#0xffffffff        ;526
000088  e7f9              B        |L14.126|
                  |L14.138|
00008a  f7fffffe          BL       EMAC_UpdatePHYStatus
00008e  2800              CMP      r0,#0                 ;530
000090  da02              BGE      |L14.152|
000092  f04f30ff          MOV      r0,#0xffffffff        ;531
000096  e7f2              B        |L14.126|
                  |L14.152|
000098  2000              MOVS     r0,#0                 ;535
00009a  e7f0              B        |L14.126|
;;;537    
                          ENDP

                  |L14.156|
                          DCD      0x20005c90

                          AREA ||i.EMAC_UpdatePHYStatus||, CODE, READONLY, ALIGN=2

                  EMAC_UpdatePHYStatus PROC
;;;548     **********************************************************************/
;;;549    int32_t EMAC_UpdatePHYStatus(void)
000000  b570              PUSH     {r4-r6,lr}
;;;550    {
;;;551    	int32_t regv, tout;
;;;552    
;;;553    	/* Check the link status. */
;;;554    #ifdef MCB_LPC_1768
;;;555    	for (tout = EMAC_PHY_RESP_TOUT; tout>=0; tout--) {
000002  f44f1580          MOV      r5,#0x100000
000006  e00c              B        |L15.34|
                  |L15.8|
;;;556    		regv = read_PHY (EMAC_PHY_REG_STS);
000008  2010              MOVS     r0,#0x10
00000a  f7fffffe          BL       read_PHY
00000e  4604              MOV      r4,r0
;;;557    		if (regv & EMAC_PHY_SR_LINK) {
000010  f0040001          AND      r0,r4,#1
000014  b100              CBZ      r0,|L15.24|
;;;558    			/* Link is on. */
;;;559    			break;
000016  e006              B        |L15.38|
                  |L15.24|
;;;560    		}
;;;561    		if (tout == 0){
000018  b915              CBNZ     r5,|L15.32|
;;;562    			// time out
;;;563    			return (-1);
00001a  f04f30ff          MOV      r0,#0xffffffff
                  |L15.30|
;;;564    		}
;;;565    	}
;;;566    	/* Configure Full/Half Duplex mode. */
;;;567    	if (regv & EMAC_PHY_SR_DUP) {
;;;568    	/* Full duplex is enabled. */
;;;569    			LPC_EMAC->MAC2    |= EMAC_MAC2_FULL_DUP;
;;;570    			LPC_EMAC->Command |= EMAC_CR_FULL_DUP;
;;;571    			LPC_EMAC->IPGT     = EMAC_IPGT_FULL_DUP;
;;;572    	} else {
;;;573    		/* Half duplex mode. */
;;;574    		LPC_EMAC->IPGT = EMAC_IPGT_HALF_DUP;
;;;575    	}
;;;576    	if (regv & EMAC_PHY_SR_SPEED) {
;;;577    	/* 10MBit mode. */
;;;578    		LPC_EMAC->SUPP = 0;
;;;579    	} else {
;;;580    		/* 100MBit mode. */
;;;581    		LPC_EMAC->SUPP = EMAC_SUPP_SPEED;
;;;582    	}
;;;583    #elif defined(IAR_LPC_1768)
;;;584    	for (tout = EMAC_PHY_RESP_TOUT; tout>=0; tout--) {
;;;585    		regv = read_PHY (EMAC_PHY_REG_BMSR);
;;;586    		if (regv & EMAC_PHY_BMSR_LINK_STATUS) {
;;;587    			/* Link is on. */
;;;588    			break;
;;;589    		}
;;;590    		if (tout == 0){
;;;591    			// time out
;;;592    			return (-1);
;;;593    		}
;;;594    	}
;;;595    
;;;596    	/* Configure Full/Half Duplex mode. */
;;;597    	if (regv & EMAC_PHY_SR_FULL_DUP) {
;;;598    		/* Full duplex is enabled. */
;;;599    		LPC_EMAC->MAC2    |= EMAC_MAC2_FULL_DUP;
;;;600    		LPC_EMAC->Command |= EMAC_CR_FULL_DUP;
;;;601    		LPC_EMAC->IPGT     = EMAC_IPGT_FULL_DUP;
;;;602    	} else {
;;;603    		/* Half duplex mode. */
;;;604    		LPC_EMAC->IPGT = EMAC_IPGT_HALF_DUP;
;;;605    	}
;;;606    
;;;607    	/* Configure 100MBit/10MBit mode. */
;;;608    	if (!(regv & EMAC_PHY_SR_100_SPEED)) {
;;;609    		/* 10MBit mode. */
;;;610    		LPC_EMAC->SUPP = 0;
;;;611    	} else {
;;;612    		/* 100MBit mode. */
;;;613    		LPC_EMAC->SUPP = EMAC_SUPP_SPEED;
;;;614    	}
;;;615    #endif
;;;616    	// Complete
;;;617    	return (0);
;;;618    }
00001e  bd70              POP      {r4-r6,pc}
                  |L15.32|
000020  1e6d              SUBS     r5,r5,#1              ;555
                  |L15.34|
000022  2d00              CMP      r5,#0                 ;555
000024  daf0              BGE      |L15.8|
                  |L15.38|
000026  bf00              NOP                            ;559
000028  f0040004          AND      r0,r4,#4              ;567
00002c  b180              CBZ      r0,|L15.80|
00002e  f04f40a0          MOV      r0,#0x50000000        ;569
000032  6840              LDR      r0,[r0,#4]            ;569
000034  f0400001          ORR      r0,r0,#1              ;569
000038  f04f41a0          MOV      r1,#0x50000000        ;569
00003c  6048              STR      r0,[r1,#4]            ;569
00003e  480e              LDR      r0,|L15.120|
000040  6800              LDR      r0,[r0,#0]            ;570
000042  f4406080          ORR      r0,r0,#0x400          ;570
000046  f8c10100          STR      r0,[r1,#0x100]        ;570
00004a  2015              MOVS     r0,#0x15              ;571
00004c  6088              STR      r0,[r1,#8]            ;571
00004e  e003              B        |L15.88|
                  |L15.80|
000050  2012              MOVS     r0,#0x12              ;574
000052  f04f41a0          MOV      r1,#0x50000000        ;574
000056  6088              STR      r0,[r1,#8]            ;574
                  |L15.88|
000058  f0040002          AND      r0,r4,#2              ;576
00005c  b120              CBZ      r0,|L15.104|
00005e  2000              MOVS     r0,#0                 ;578
000060  f04f41a0          MOV      r1,#0x50000000        ;578
000064  6188              STR      r0,[r1,#0x18]         ;578
000066  e004              B        |L15.114|
                  |L15.104|
000068  f44f7080          MOV      r0,#0x100             ;581
00006c  f04f41a0          MOV      r1,#0x50000000        ;581
000070  6188              STR      r0,[r1,#0x18]         ;581
                  |L15.114|
000072  2000              MOVS     r0,#0                 ;617
000074  e7d3              B        |L15.30|
;;;619    
                          ENDP

000076  0000              DCW      0x0000
                  |L15.120|
                          DCD      0x50000100

                          AREA ||i.EMAC_UpdateRxConsumeIndex||, CODE, READONLY, ALIGN=2

                  EMAC_UpdateRxConsumeIndex PROC
;;;924     **********************************************************************/
;;;925    void EMAC_UpdateRxConsumeIndex(void)
000000  4904              LDR      r1,|L16.20|
;;;926    {
;;;927    	// Get current Rx consume index
;;;928    	uint32_t idx = LPC_EMAC->RxConsumeIndex;
000002  6808              LDR      r0,[r1,#0]
;;;929    
;;;930    	/* Release frame from EMAC buffer */
;;;931    	if (++idx == EMAC_NUM_RX_FRAG) idx = 0;
000004  1c41              ADDS     r1,r0,#1
000006  4608              MOV      r0,r1
000008  2904              CMP      r1,#4
00000a  d100              BNE      |L16.14|
00000c  2000              MOVS     r0,#0
                  |L16.14|
;;;932    	LPC_EMAC->RxConsumeIndex = idx;
00000e  4901              LDR      r1,|L16.20|
000010  6008              STR      r0,[r1,#0]
;;;933    }
000012  4770              BX       lr
;;;934    
                          ENDP

                  |L16.20|
                          DCD      0x50000118

                          AREA ||i.EMAC_UpdateTxProduceIndex||, CODE, READONLY, ALIGN=2

                  EMAC_UpdateTxProduceIndex PROC
;;;941     **********************************************************************/
;;;942    void EMAC_UpdateTxProduceIndex(void)
000000  4904              LDR      r1,|L17.20|
;;;943    {
;;;944    	// Get current Tx produce index
;;;945    	uint32_t idx = LPC_EMAC->TxProduceIndex;
000002  6808              LDR      r0,[r1,#0]
;;;946    
;;;947    	/* Start frame transmission */
;;;948    	if (++idx == EMAC_NUM_TX_FRAG) idx = 0;
000004  1c41              ADDS     r1,r0,#1
000006  4608              MOV      r0,r1
000008  2903              CMP      r1,#3
00000a  d100              BNE      |L17.14|
00000c  2000              MOVS     r0,#0
                  |L17.14|
;;;949    	LPC_EMAC->TxProduceIndex = idx;
00000e  4901              LDR      r1,|L17.20|
000010  6008              STR      r0,[r1,#0]
;;;950    }
000012  4770              BX       lr
;;;951    
                          ENDP

                  |L17.20|
                          DCD      0x50000128

                          AREA ||i.EMAC_WritePacketBuffer||, CODE, READONLY, ALIGN=2

                  EMAC_WritePacketBuffer PROC
;;;734     **********************************************************************/
;;;735    void EMAC_WritePacketBuffer(EMAC_PACKETBUF_Type *pDataStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;736    {
;;;737    	uint32_t idx,len;
;;;738    	uint32_t *sp,*dp;
;;;739    
;;;740    	idx = LPC_EMAC->TxProduceIndex;
000002  4d0c              LDR      r5,|L18.52|
000004  6829              LDR      r1,[r5,#0]
;;;741    	sp  = (uint32_t *)pDataStruct->pbDataBuf;
000006  6844              LDR      r4,[r0,#4]
;;;742    	dp  = (uint32_t *)Tx_Desc[idx].Packet;
000008  4d0b              LDR      r5,|L18.56|
00000a  f8553031          LDR      r3,[r5,r1,LSL #3]
;;;743    	/* Copy frame data to EMAC packet buffers. */
;;;744    	for (len = (pDataStruct->ulDataLen + 3) >> 2; len; len--) {
00000e  6805              LDR      r5,[r0,#0]
000010  1ced              ADDS     r5,r5,#3
000012  08aa              LSRS     r2,r5,#2
000014  e002              B        |L18.28|
                  |L18.22|
;;;745    		*dp++ = *sp++;
000016  cc20              LDM      r4!,{r5}
000018  c320              STM      r3!,{r5}
00001a  1e52              SUBS     r2,r2,#1              ;744
                  |L18.28|
00001c  2a00              CMP      r2,#0                 ;744
00001e  d1fa              BNE      |L18.22|
;;;746    	}
;;;747    	Tx_Desc[idx].Ctrl = (pDataStruct->ulDataLen - 1) | (EMAC_TCTRL_INT | EMAC_TCTRL_LAST);
000020  6805              LDR      r5,[r0,#0]
000022  1e6d              SUBS     r5,r5,#1
000024  f0454540          ORR      r5,r5,#0xc0000000
000028  4e03              LDR      r6,|L18.56|
00002a  eb0606c1          ADD      r6,r6,r1,LSL #3
00002e  6075              STR      r5,[r6,#4]
;;;748    }
000030  bd70              POP      {r4-r6,pc}
;;;749    
                          ENDP

000032  0000              DCW      0x0000
                  |L18.52|
                          DCD      0x50000128
                  |L18.56|
                          DCD      Tx_Desc

                          AREA ||i.emac_CRCCalc||, CODE, READONLY, ALIGN=2

                  emac_CRCCalc PROC
;;;232     **********************************************************************/
;;;233    static int32_t emac_CRCCalc(uint8_t frame_no_fcs[], int32_t frame_len)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;234    {
000004  4602              MOV      r2,r0
000006  460b              MOV      r3,r1
;;;235    	int i; 		// iterator
;;;236    	int j; 		// another iterator
;;;237    	char byte; 	// current byte
;;;238    	int crc; 	// CRC result
;;;239    	int q0, q1, q2, q3; // temporary variables
;;;240    	crc = 0xFFFFFFFF;
000008  f04f30ff          MOV      r0,#0xffffffff
;;;241    	for (i = 0; i < frame_len; i++) {
00000c  2400              MOVS     r4,#0
00000e  e042              B        |L19.150|
                  |L19.16|
;;;242    		byte = *frame_no_fcs++;
000010  f8121b01          LDRB     r1,[r2],#1
;;;243    		for (j = 0; j < 2; j++) {
000014  2500              MOVS     r5,#0
000016  e03b              B        |L19.144|
                  |L19.24|
;;;244    			if (((crc >> 28) ^ (byte >> 3)) & 0x00000001) {
000018  ea4f7920          ASR      r9,r0,#28
00001c  ea8909e1          EOR      r9,r9,r1,ASR #3
000020  f0090901          AND      r9,r9,#1
000024  f1b90f00          CMP      r9,#0
000028  d002              BEQ      |L19.48|
;;;245    				q3 = 0x04C11DB7;
00002a  f8df8074          LDR      r8,|L19.160|
00002e  e001              B        |L19.52|
                  |L19.48|
;;;246    			} else {
;;;247    				q3 = 0x00000000;
000030  f04f0800          MOV      r8,#0
                  |L19.52|
;;;248    			}
;;;249    			if (((crc >> 29) ^ (byte >> 2)) & 0x00000001) {
000034  ea4f7960          ASR      r9,r0,#29
000038  ea8909a1          EOR      r9,r9,r1,ASR #2
00003c  f0090901          AND      r9,r9,#1
000040  f1b90f00          CMP      r9,#0
000044  d002              BEQ      |L19.76|
;;;250    				q2 = 0x09823B6E;
000046  f8dfc05c          LDR      r12,|L19.164|
00004a  e001              B        |L19.80|
                  |L19.76|
;;;251    			} else {
;;;252    				q2 = 0x00000000;
00004c  f04f0c00          MOV      r12,#0
                  |L19.80|
;;;253    			}
;;;254    			if (((crc >> 30) ^ (byte >> 1)) & 0x00000001) {
000050  ea4f79a0          ASR      r9,r0,#30
000054  ea890961          EOR      r9,r9,r1,ASR #1
000058  f0090901          AND      r9,r9,#1
00005c  f1b90f00          CMP      r9,#0
000060  d001              BEQ      |L19.102|
;;;255    				q1 = 0x130476DC;
000062  4f11              LDR      r7,|L19.168|
000064  e000              B        |L19.104|
                  |L19.102|
;;;256    			} else {
;;;257    				q1 = 0x00000000;
000066  2700              MOVS     r7,#0
                  |L19.104|
;;;258    			}
;;;259    			if (((crc >> 31) ^ (byte >> 0)) & 0x00000001) {
000068  ea8179e0          EOR      r9,r1,r0,ASR #31
00006c  f0090901          AND      r9,r9,#1
000070  f1b90f00          CMP      r9,#0
000074  d001              BEQ      |L19.122|
;;;260    				q0 = 0x2608EDB8;
000076  4e0d              LDR      r6,|L19.172|
000078  e000              B        |L19.124|
                  |L19.122|
;;;261    			} else {
;;;262    				q0 = 0x00000000;
00007a  2600              MOVS     r6,#0
                  |L19.124|
;;;263    			}
;;;264    			crc = (crc << 4) ^ q3 ^ q2 ^ q1 ^ q0;
00007c  ea881900          EOR      r9,r8,r0,LSL #4
000080  ea89090c          EOR      r9,r9,r12
000084  ea890907          EOR      r9,r9,r7
000088  ea890006          EOR      r0,r9,r6
;;;265    			byte >>= 4;
00008c  1109              ASRS     r1,r1,#4
00008e  1c6d              ADDS     r5,r5,#1              ;243
                  |L19.144|
000090  2d02              CMP      r5,#2                 ;243
000092  dbc1              BLT      |L19.24|
000094  1c64              ADDS     r4,r4,#1              ;241
                  |L19.150|
000096  429c              CMP      r4,r3                 ;241
000098  dbba              BLT      |L19.16|
;;;266    		}
;;;267    	}
;;;268    	return crc;
;;;269    }
00009a  e8bd83f0          POP      {r4-r9,pc}
;;;270    /* End of Private Functions --------------------------------------------------- */
                          ENDP

00009e  0000              DCW      0x0000
                  |L19.160|
                          DCD      0x04c11db7
                  |L19.164|
                          DCD      0x09823b6e
                  |L19.168|
                          DCD      0x130476dc
                  |L19.172|
                          DCD      0x2608edb8

                          AREA ||i.read_PHY||, CODE, READONLY, ALIGN=1

                  read_PHY PROC
;;;191     ***********************************************************************/
;;;192    static int32_t read_PHY (uint32_t PhyReg)
000000  4601              MOV      r1,r0
;;;193    {
;;;194    	/* Read a PHY register 'PhyReg'. */
;;;195    	uint32_t tout;
;;;196    
;;;197    	LPC_EMAC->MADR = EMAC_DEF_ADR | PhyReg;
000002  f4417080          ORR      r0,r1,#0x100
000006  f04f43a0          MOV      r3,#0x50000000
00000a  6298              STR      r0,[r3,#0x28]
;;;198    	LPC_EMAC->MCMD = EMAC_MCMD_READ;
00000c  2001              MOVS     r0,#1
00000e  6258              STR      r0,[r3,#0x24]
;;;199    
;;;200    	/* Wait until operation completed */
;;;201    	tout = 0;
000010  2200              MOVS     r2,#0
;;;202    	for (tout = 0; tout < EMAC_MII_RD_TOUT; tout++) {
000012  bf00              NOP      
000014  e00d              B        |L20.50|
                  |L20.22|
;;;203    		if ((LPC_EMAC->MIND & EMAC_MIND_BUSY) == 0) {
000016  f04f40a0          MOV      r0,#0x50000000
00001a  6b40              LDR      r0,[r0,#0x34]
00001c  f0000001          AND      r0,r0,#1
000020  b930              CBNZ     r0,|L20.48|
;;;204    			LPC_EMAC->MCMD = 0;
000022  2000              MOVS     r0,#0
000024  f04f43a0          MOV      r3,#0x50000000
000028  6258              STR      r0,[r3,#0x24]
;;;205    			return (LPC_EMAC->MRDD);
00002a  4618              MOV      r0,r3
00002c  6b00              LDR      r0,[r0,#0x30]
                  |L20.46|
;;;206    		}
;;;207    	}
;;;208    	// Time out!
;;;209    	return (-1);
;;;210    }
00002e  4770              BX       lr
                  |L20.48|
000030  1c52              ADDS     r2,r2,#1              ;202
                  |L20.50|
000032  f5b22fa0          CMP      r2,#0x50000           ;202
000036  d3ee              BCC      |L20.22|
000038  f04f30ff          MOV      r0,#0xffffffff        ;209
00003c  e7f7              B        |L20.46|
;;;211    
                          ENDP


                          AREA ||i.rx_descr_init||, CODE, READONLY, ALIGN=2

                  rx_descr_init PROC
;;;108     ***********************************************************************/
;;;109    static void rx_descr_init (void)
000000  2000              MOVS     r0,#0
;;;110    {
;;;111    	/* Initialize Receive Descriptor and Status array. */
;;;112    	uint32_t i;
;;;113    
;;;114    	for (i = 0; i < EMAC_NUM_RX_FRAG; i++) {
000002  e013              B        |L21.44|
                  |L21.4|
;;;115    		Rx_Desc[i].Packet  = (uint32_t)&rx_buf[i];
000004  eb000140          ADD      r1,r0,r0,LSL #1
000008  4a12              LDR      r2,|L21.84|
00000a  eb022141          ADD      r1,r2,r1,LSL #9
00000e  4a12              LDR      r2,|L21.88|
000010  f8421030          STR      r1,[r2,r0,LSL #3]
;;;116    		Rx_Desc[i].Ctrl    = EMAC_RCTRL_INT | (EMAC_ETH_MAX_FLEN - 1);
000014  4911              LDR      r1,|L21.92|
000016  eb0202c0          ADD      r2,r2,r0,LSL #3
00001a  6051              STR      r1,[r2,#4]
;;;117    		Rx_Stat[i].Info    = 0;
00001c  2100              MOVS     r1,#0
00001e  4a10              LDR      r2,|L21.96|
000020  f8421030          STR      r1,[r2,r0,LSL #3]
;;;118    		Rx_Stat[i].HashCRC = 0;
000024  eb0202c0          ADD      r2,r2,r0,LSL #3
000028  6051              STR      r1,[r2,#4]
00002a  1c40              ADDS     r0,r0,#1              ;114
                  |L21.44|
00002c  2804              CMP      r0,#4                 ;114
00002e  d3e9              BCC      |L21.4|
;;;119    	}
;;;120    
;;;121    	/* Set EMAC Receive Descriptor Registers. */
;;;122    	LPC_EMAC->RxDescriptor       = (uint32_t)&Rx_Desc[0];
000030  4909              LDR      r1,|L21.88|
000032  4a0c              LDR      r2,|L21.100|
000034  6011              STR      r1,[r2,#0]
;;;123    	LPC_EMAC->RxStatus           = (uint32_t)&Rx_Stat[0];
000036  490a              LDR      r1,|L21.96|
000038  f04f42a0          MOV      r2,#0x50000000
00003c  f8c2110c          STR      r1,[r2,#0x10c]
;;;124    	LPC_EMAC->RxDescriptorNumber = EMAC_NUM_RX_FRAG - 1;
000040  2103              MOVS     r1,#3
000042  4a08              LDR      r2,|L21.100|
000044  3208              ADDS     r2,r2,#8
000046  6011              STR      r1,[r2,#0]
;;;125    
;;;126    	/* Rx Descriptors Point to 0 */
;;;127    	LPC_EMAC->RxConsumeIndex  = 0;
000048  2100              MOVS     r1,#0
00004a  f04f42a0          MOV      r2,#0x50000000
00004e  f8c21118          STR      r1,[r2,#0x118]
;;;128    }
000052  4770              BX       lr
;;;129    
                          ENDP

                  |L21.84|
                          DCD      rx_buf
                  |L21.88|
                          DCD      Rx_Desc
                  |L21.92|
                          DCD      0x800005ff
                  |L21.96|
                          DCD      Rx_Stat
                  |L21.100|
                          DCD      0x50000108

                          AREA ||i.setEmacAddr||, CODE, READONLY, ALIGN=1

                  setEmacAddr PROC
;;;217     **********************************************************************/
;;;218    static void setEmacAddr(uint8_t abStationAddr[])
000000  7901              LDRB     r1,[r0,#4]
;;;219    {
;;;220    	/* Set the Ethernet MAC Address registers */
;;;221    	LPC_EMAC->SA0 = ((uint32_t)abStationAddr[5] << 8) | (uint32_t)abStationAddr[4];
000002  7942              LDRB     r2,[r0,#5]
000004  ea412102          ORR      r1,r1,r2,LSL #8
000008  f04f42a0          MOV      r2,#0x50000000
00000c  6411              STR      r1,[r2,#0x40]
;;;222    	LPC_EMAC->SA1 = ((uint32_t)abStationAddr[3] << 8) | (uint32_t)abStationAddr[2];
00000e  7881              LDRB     r1,[r0,#2]
000010  78c2              LDRB     r2,[r0,#3]
000012  ea412102          ORR      r1,r1,r2,LSL #8
000016  f04f42a0          MOV      r2,#0x50000000
00001a  6451              STR      r1,[r2,#0x44]
;;;223    	LPC_EMAC->SA2 = ((uint32_t)abStationAddr[1] << 8) | (uint32_t)abStationAddr[0];
00001c  7801              LDRB     r1,[r0,#0]
00001e  7842              LDRB     r2,[r0,#1]
000020  ea412102          ORR      r1,r1,r2,LSL #8
000024  f04f42a0          MOV      r2,#0x50000000
000028  6491              STR      r1,[r2,#0x48]
;;;224    }
00002a  4770              BX       lr
;;;225    
                          ENDP


                          AREA ||i.tx_descr_init||, CODE, READONLY, ALIGN=2

                  tx_descr_init PROC
;;;136     ***********************************************************************/
;;;137    static void tx_descr_init (void) {
000000  2000              MOVS     r0,#0
;;;138    	/* Initialize Transmit Descriptor and Status array. */
;;;139    	uint32_t i;
;;;140    
;;;141    	for (i = 0; i < EMAC_NUM_TX_FRAG; i++) {
000002  e00f              B        |L23.36|
                  |L23.4|
;;;142    		Tx_Desc[i].Packet = (uint32_t)&tx_buf[i];
000004  eb000140          ADD      r1,r0,r0,LSL #1
000008  4a10              LDR      r2,|L23.76|
00000a  eb022141          ADD      r1,r2,r1,LSL #9
00000e  4a10              LDR      r2,|L23.80|
000010  f8421030          STR      r1,[r2,r0,LSL #3]
;;;143    		Tx_Desc[i].Ctrl   = 0;
000014  2100              MOVS     r1,#0
000016  eb0202c0          ADD      r2,r2,r0,LSL #3
00001a  6051              STR      r1,[r2,#4]
;;;144    		Tx_Stat[i].Info   = 0;
00001c  4a0d              LDR      r2,|L23.84|
00001e  f8421020          STR      r1,[r2,r0,LSL #2]
000022  1c40              ADDS     r0,r0,#1              ;141
                  |L23.36|
000024  2803              CMP      r0,#3                 ;141
000026  d3ed              BCC      |L23.4|
;;;145    	}
;;;146    
;;;147    	/* Set EMAC Transmit Descriptor Registers. */
;;;148    	LPC_EMAC->TxDescriptor       = (uint32_t)&Tx_Desc[0];
000028  4909              LDR      r1,|L23.80|
00002a  4a0b              LDR      r2,|L23.88|
00002c  6011              STR      r1,[r2,#0]
;;;149    	LPC_EMAC->TxStatus           = (uint32_t)&Tx_Stat[0];
00002e  4909              LDR      r1,|L23.84|
000030  f04f42a0          MOV      r2,#0x50000000
000034  f8c21120          STR      r1,[r2,#0x120]
;;;150    	LPC_EMAC->TxDescriptorNumber = EMAC_NUM_TX_FRAG - 1;
000038  2102              MOVS     r1,#2
00003a  4a07              LDR      r2,|L23.88|
00003c  3208              ADDS     r2,r2,#8
00003e  6011              STR      r1,[r2,#0]
;;;151    
;;;152    	/* Tx Descriptors Point to 0 */
;;;153    	LPC_EMAC->TxProduceIndex  = 0;
000040  2100              MOVS     r1,#0
000042  f04f42a0          MOV      r2,#0x50000000
000046  f8c21128          STR      r1,[r2,#0x128]
;;;154    }
00004a  4770              BX       lr
;;;155    
                          ENDP

                  |L23.76|
                          DCD      tx_buf
                  |L23.80|
                          DCD      Tx_Desc
                  |L23.84|
                          DCD      Tx_Stat
                  |L23.88|
                          DCD      0x5000011c

                          AREA ||i.write_PHY||, CODE, READONLY, ALIGN=1

                  write_PHY PROC
;;;164     ***********************************************************************/
;;;165    static int32_t write_PHY (uint32_t PhyReg, uint16_t Value)
000000  b510              PUSH     {r4,lr}
;;;166    {
000002  4602              MOV      r2,r0
;;;167    	/* Write a data 'Value' to PHY register 'PhyReg'. */
;;;168    	uint32_t tout;
;;;169    
;;;170    	LPC_EMAC->MADR = EMAC_DEF_ADR | PhyReg;
000004  f4427080          ORR      r0,r2,#0x100
000008  f04f44a0          MOV      r4,#0x50000000
00000c  62a0              STR      r0,[r4,#0x28]
;;;171    	LPC_EMAC->MWTD = Value;
00000e  4620              MOV      r0,r4
000010  62c1              STR      r1,[r0,#0x2c]
;;;172    
;;;173    	/* Wait until operation completed */
;;;174    	tout = 0;
000012  2300              MOVS     r3,#0
;;;175    	for (tout = 0; tout < EMAC_MII_WR_TOUT; tout++) {
000014  bf00              NOP      
000016  e008              B        |L24.42|
                  |L24.24|
;;;176    		if ((LPC_EMAC->MIND & EMAC_MIND_BUSY) == 0) {
000018  f04f40a0          MOV      r0,#0x50000000
00001c  6b40              LDR      r0,[r0,#0x34]
00001e  f0000001          AND      r0,r0,#1
000022  b908              CBNZ     r0,|L24.40|
;;;177    			return (0);
000024  2000              MOVS     r0,#0
                  |L24.38|
;;;178    		}
;;;179    	}
;;;180    	// Time out!
;;;181    	return (-1);
;;;182    }
000026  bd10              POP      {r4,pc}
                  |L24.40|
000028  1c5b              ADDS     r3,r3,#1              ;175
                  |L24.42|
00002a  f5b32fa0          CMP      r3,#0x50000           ;175
00002e  d3f3              BCC      |L24.24|
000030  f04f30ff          MOV      r0,#0xffffffff        ;181
000034  e7f7              B        |L24.38|
;;;183    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=3

                  Rx_Desc
                          %        32
                  Rx_Stat
                          %        32
                  Tx_Desc
                          %        24
                  Tx_Stat
                          %        12
                  rx_buf
                          %        6144
                  tx_buf
                          %        4608

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  EMAC_clkdiv
000000  0406080a          DCB      0x04,0x06,0x08,0x0a
000004  0e141c24          DCB      0x0e,0x14,0x1c,0x24
000008  282c3034          DCB      0x28,0x2c,0x30,0x34
00000c  383c40            DCB      0x38,0x3c,0x40

;*** Start embedded assembler ***

#line 1 "Lib\\Drivers\\source\\lpc17xx_emac.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_lpc17xx_emac_c_60b833e4____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___14_lpc17xx_emac_c_60b833e4____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_lpc17xx_emac_c_60b833e4____REVSH|
#line 144
|__asm___14_lpc17xx_emac_c_60b833e4____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
